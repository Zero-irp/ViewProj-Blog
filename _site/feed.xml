<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/ViewProj-Blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ViewProj-Blog/" rel="alternate" type="text/html" /><updated>2025-11-13T00:19:13+05:30</updated><id>http://localhost:4000/ViewProj-Blog/feed.xml</id><title type="html">Reversing The ViewProjection Matrix</title><subtitle>Reversing The Construction Of The View-Projection Matrix</subtitle><author><name>z1rp</name></author><entry><title type="html">Part 1: Introduction</title><link href="http://localhost:4000/ViewProj-Blog/part-1-intro/" rel="alternate" type="text/html" title="Part 1: Introduction" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-1-intro</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-1-intro/"><![CDATA[<h3 id="️-disclaimer">⚠️ Disclaimer:</h3>
<p>The content on this blog is provided for educational and informational purposes only. I do not encourage, endorse, or support any illegal activity. 
Any techniques, tools, or concepts discussed are intended solely for learning, research, defensive security, or experimentation in safe, legal 
environments. Use this information responsibly and at your own risk. The author is not responsible for any misuse or legal consequences that may 
result from applying what’s written here.</p>

<h3 id="how-this-rabbit-hole-started"><strong>How This Rabbit Hole Started:</strong></h3>

<p>It all began when I was messing around with Ghost of Tsushima, trying to locate the View-Projection matrix to build a working world-to-screen (w2s) function. I eventually found it 
and it worked as intended. But while digging through memory, I came across several other interesting matrices. Two of them stood out: the Camera World Matrix and the Perspective 
Projection Matrix. I figured i could reconstruct the View-Projection matrix myself by multiplying the inverse of the camera world matrix with projection matrix the as most Direct-X games 
do. But the result didn’t match the actual View-Projection matrix.
Curious, I started tracing the functions that write to the View-Projection matrix using IDA Pro, ReClass, and Cheat Engine. That’s when I discovered the engine was building 
the matrix in a non-standard way, or at least, a way that was unfamiliar to me and different from the basic graphics pipeline I was expecting.</p>

<h3 id="prerequisites"><strong>Prerequisites</strong></h3>
<ul>
  <li>Understanding the assembly language (x86-64)</li>
  <li>Basic Reverse Engineering Skills</li>
  <li>Intermediate knowledge in C++</li>
  <li>Windows API Familiarity</li>
  <li>Linear algebra
    <blockquote>
      <p>I assume you already understand the linear-algebra concepts used throughout: vectors, matrices (4×4), homogeneous coordinates (Vec4(x,y,z,1)), dot/cross products, matrix × vector, and the perspective divide</p>
    </blockquote>
  </li>
</ul>

<h3 id="what-are-we-trying-to-achieve"><strong>What Are we Trying to achieve?</strong></h3>

<p>In this write-up series, we’re going to reverse engineer how <em>Ghost of Tsushima</em> constructs its <strong>View-Projection matrix</strong>, the thing that turns 3D world positions into 2D screen 
coordinates. This is super important for stuff like ESP overlays (you can’t draw a box around an enemy if you don’t know where they are on screen).</p>

<p>We’ll be reverse engineering the game’s rendering pipeline using tools like IDA Pro, breaking down how the View-Projection matrix is built step by step including all the weird 
SIMD instructions it uses. The goal is to figure out where it’s stored, how it’s constructed, and how it’s used in the game.</p>

<h3 id="what-is-an-esp"><strong>What is an ESP?</strong></h3>

<p>ESP stands for <em>Extra-Sensory Perception</em>. In game hacking, it refers to any feature that shows you information you normally wouldn’t be able to see, stuff the game doesn’t intend to show.
For example, an ESP might let you:</p>
<ul>
  <li>See players through walls</li>
  <li>Know their exact health</li>
  <li>Track what’s in their inventory</li>
  <li>Spot hidden loot, traps etc…</li>
</ul>

<p>This gives a huge unfair advantage over others.</p>

<h3 id="write-up-outline"><strong>Write-Up Outline:</strong></h3>

<ul>
  <li><strong><a href="../part-1-intro/">Part 1: Introduction</a></strong>
    <ul>
      <li><a href="../part-1-intro/#how-this-rabbit-hole-started">How This Rabbit Hole Started</a></li>
      <li><a href="../part-1-intro/#prerequisites">Prerequisites</a></li>
      <li><a href="../part-1-intro/#what-are-we-trying-to-achieve">What Are we Trying to achieve?</a></li>
      <li><a href="../part-1-intro/#what-is-an-esp">What is an ESP?</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-2.1-view-matrix/">Part 2.1: View Matrix</a></strong>
    <ul>
      <li><a href="../part-2.1-view-matrix/#introduction">Introduction</a></li>
      <li><a href="../part-2.1-view-matrix/#camera-world-matrix">Camera World Matrix</a></li>
      <li><a href="../part-2.1-view-matrix/#what-is-a-view-matrix">What is a View-Matrix?</a></li>
      <li><a href="../part-2.1-view-matrix/#layout-of-the-view-matrix">Layout Of the View Matrix</a></li>
      <li><a href="../part-2.1-view-matrix/#breaking-down-the-view-matrix-vectors">Breaking Down the View Matrix Vectors</a></li>
      <li><a href="../part-2.1-view-matrix/#orthogonality-and-relations--optionalgood-to-know">Orthogonality and Relations:- (Optional / Good to know)</a></li>
      <li><a href="../part-2.1-view-matrix/#model-matrix--optionalgood-to-know">Model Matrix (Optional / Good to know)</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-2.2-projection-matrix/">Part 2.2: Projection Matrix</a></strong>
    <ul>
      <li><a href="../part-2.2-projection-matrix/#what-is-the-projection-matrix">What is the Projection Matrix?</a></li>
      <li><a href="../part-2.2-projection-matrix/#what-the-projection-matrix-does">What the Projection Matrix Does</a></li>
      <li><a href="../part-2.2-projection-matrix/#layout-of-the-perspective-projection-matrix">Layout of the Perspective Projection Matrix</a></li>
      <li><a href="../part-2.2-projection-matrix/#relationship-between-horizontal-and-vertical-fov">Relationship Between Horizontal and Vertical FOV</a></li>
      <li><a href="../part-2.2-projection-matrix/#what-is-reverse-z">What is Reverse Z?</a></li>
      <li><a href="../part-2.2-projection-matrix/#layout-of-reverse-z-projection-matrix">Layout of Reverse Z Projection Matrix</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-2.3-View-Projection-matrix/">Part 2.3: View Projection Matrix</a></strong>
    <ul>
      <li><a href="../part-2.3-View-Projection-matrix/#what-is-the-view-projection-matrix">What is the View-Projection Matrix?</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-3-finding-and-reversing-matrices/">Part 3: Finding &amp; Reversing Matrices</a></strong>
    <ul>
      <li><a href="../part-3-finding-and-reversing-matrices/#how-we-search-for-matrices-in-memory">How We Search for Matrices in Memory</a></li>
      <li><a href="../part-3-finding-and-reversing-matrices/#searching-for-matrices-in-ghost-of-tsushima">Searching for Matrices in Ghost of Tsushima</a></li>
      <li><a href="../part-3-finding-and-reversing-matrices/#confirmation-of-the-view-and-camera-world-matrices">Confirmation of the View and Camera World Matrices</a></li>
      <li><a href="../part-3-finding-and-reversing-matrices/#looking-at-other-matrices">Looking at other matrices (Projection, VP etc)</a></li>
      <li><a href="../part-3-finding-and-reversing-matrices/#other-ways-to-get-the-vp-matrix">Other ways to get the VP matrix</a></li>
      <li><a href="../part-3-finding-and-reversing-matrices/#trying-to-rebuild-the-view-projection-matrix">Trying to Rebuild the View-Projection Matrix</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-4.1-tracing-matrix-construction/">Part 4.1: Tracing the Matrix Construction Path</a></strong>
    <ul>
      <li><a href="../part-4.1-tracing-matrix-construction/#tracing-functions-writing-to-the-view-projection-matrix">Tracing Functions Writing to The View-Projection Matrix</a></li>
      <li><a href="../part-4.1-tracing-matrix-construction/#windows-calling-conventions-abi">Windows Calling Conventions (ABI)</a></li>
      <li><a href="../part-4.1-tracing-matrix-construction/#breakpoint--stacktrace">BreakPoints, Stacktrace etc</a></li>
      <li><a href="../part-4.1-tracing-matrix-construction/#ida-code">Looking at functions in IDA PRO</a></li>
      <li><a href="../part-4.1-tracing-matrix-construction/#why-not-just-invert-it">View Matrix Recovery through Matrix Algebra</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-4.2-reversing-simd-instrustions/">Part 4.2: Reversing SIMD Instructions for Matrix Math</a></strong>
    <ul>
      <li><a href="../part-4.2-reversing-simd-instrustions/#reversing-simd-instructions">Reversing SIMD instructions</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#masking-out-w-with-simd-theory">Masking Out w with SIMD (Theory)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#_mm_shuffle_ps-theory">_mm_shuffle_ps (Theory)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#negating-a-vector-with-simd-theory">Negating a Vector with SIMD (Theory)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#_mm_unpack-theory">_mm_unpack (Theory)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#transposing-and-shuffling-intermediate-vectors-theory">Transposing and Shuffling Intermediate Vectors (Theory)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#manual-matrix-reconstruction-from-simd-operations-example">Manual Matrix Reconstruction from SIMD Operations (Example)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#simd-based-vec4--4x4-matrix-multiplication-theory">SIMD-Based Vec4 × 4x4 Matrix Multiplication (Theory)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#comparing-constructed-matrix-with-camera-world-matrix">Comparing Constructed Matrix with Camera World Matrix:</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#fast-inverse-for-orthonormal-matrices">Fast inverse for orthonormal Matrices</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#continuaton-of-manual-matrix-reconstruction-example">Continuation of Manual Matrix Reconstruction (Example)</a></li>
      <li><a href="../part-4.2-reversing-simd-instrustions/#confirmation-of-vp-matrix">Confirmation Of VP Matrix from Manual Construction</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-4.3-completing-view-proj-matrix/">Part 4.3: Completing the View-Projection Matrix</a></strong>
    <ul>
      <li><a href="../part-4.3-completing-view-proj-matrix/#matrix-loading-into-memory">Matrix Loading into Memory</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#making-sense">Making sense</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#another-redundant-simd-math-function">Many Redundant SIMD math functions</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#negated-camera-position-multiplication-with-viewprojection-matrix">Negated Camera position Multiplication with View-Projection Matrix</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#even-more-redundant-simd-operations">Even More redundant SIMD operations</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#biggest-reduction-in-simd-operations">Biggest reduction in SIMD operations</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#continuaton-of-manual-matrix-reconstruction">Continuation of Manual Matrix Reconstruction</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#the-viewprojection-matrix---fully-reversed">The View-Projection Matrix - Fully Reversed</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#final-verification">Final Verification</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#camera-world-matrix-does-not-match">Camera World Matrix Does Not Match?</a></li>
      <li><a href="../part-4.3-completing-view-proj-matrix/#completion-of-vp-matrix-construction-from-simd-operations">Completion of VP matrix construction from SIMD operations</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-4.4-optimizing-redundant-simd-instructions/">Part 4.4: Optimizing Redundant SIMD Instructions</a></strong>
    <ul>
      <li><a href="../part-4.4-optimizing-redundant-simd-instructions/#finding-assembly-responsible-for-this-function">Finding Assembly responsible for this function</a></li>
      <li><a href="../part-4.4-optimizing-redundant-simd-instructions/#nopping-instructions">Nopping Instructions</a></li>
      <li><a href="../part-4.4-optimizing-redundant-simd-instructions/#result">Result of game running smoothly</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-4.5-detour-hooking-simd-operations/">Part 4.5: Detour Hooking to Optimize SIMD Operations</a></strong>
    <ul>
      <li><a href="../part-4.5-detour-hooking-simd-operations/#what-is-detour-hooking">What is detour Hooking?</a></li>
      <li><a href="../part-4.5-detour-hooking-simd-operations/#heres-the-approach">The approach</a></li>
      <li><a href="../part-4.5-detour-hooking-simd-operations/#5-byte-jmp-hook-vs-12-byte-jmp-hook">5 Byte Jmp hook vs 12 Byte Jmp hook</a></li>
      <li><a href="../part-4.5-detour-hooking-simd-operations/#writing-our-hook">Writing our hook</a></li>
      <li><a href="../part-4.5-detour-hooking-simd-operations/#code-explanation">Code Explanation:</a></li>
      <li><a href="../part-4.5-detour-hooking-simd-operations/#executing-our-hook">Executing our hook</a></li>
      <li><a href="../part-4.5-detour-hooking-simd-operations/#observations-in-game-and-memory">Observations in game and memory</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-5-trampoline-hooking/">Part 5: Trampoline Hooking to Capture Entity Positions</a></strong>
    <ul>
      <li><a href="../part-5-trampoline-hooking/#what-is-trampoline-hooking">What is Trampoline Hooking?</a></li>
      <li><a href="../part-5-trampoline-hooking/#the-plan">The Plan</a></li>
      <li><a href="../part-5-trampoline-hooking/#the-hook">The Hook</a></li>
      <li><a href="../part-5-trampoline-hooking/#setting-up-memory-for-the-trampoline">Setting Up Memory for the Trampoline</a></li>
      <li><a href="../part-5-trampoline-hooking/#hooking-the-z-axis-instruction">Hooking the Z-Axis Instruction</a></li>
      <li><a href="../part-5-trampoline-hooking/#writing-the-trampoline">Writing the Trampoline</a></li>
      <li><a href="../part-5-trampoline-hooking/#capturing--storing-entities">Capturing &amp; Storing Entities</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-6-w2s/">Part 6: World To Screen Explanation And Code</a></strong>
    <ul>
      <li><a href="../part-6-w2s/#what-world-to-screen-means">What “World to Screen” Means</a></li>
      <li><a href="../part-6-w2s/#world-to-screen-code-explanation">World to Screen Code Explanation</a>
        <ul>
          <li><a href="../part-6-w2s/../part-6-w2s/#world-space--clip-space">World Space → Clip Space</a></li>
          <li><a href="../part-6-w2s/../part-6-w2s/#clip-check">Clip Check</a></li>
          <li><a href="../part-6-w2s/../part-6-w2s/#clip-space--ndc">Clip Space → NDC</a></li>
          <li><a href="../part-6-w2s/../part-6-w2s/#ndc--screen-space">NDC → Screen Space</a></li>
        </ul>
      </li>
      <li><a href="../part-6-w2s/#summary-of-the-transformation-pipeline">Summary of the Transformation Pipeline</a></li>
      <li><a href="../part-6-w2s/#tldr-of-w2s">TL;DR of w2s</a></li>
    </ul>
  </li>
  <li><strong><a href="../part-7-final-esp/">Part 7: Final ESP with ImGui</a></strong>
    <ul>
      <li><a href="../part-7-final-esp/#introduction">Introduction</a></li>
      <li><a href="../part-7-final-esp/#code-explanation">Entire Code Explanation</a>
        <ul>
          <li>Step 1: Reading Entities and Their Data</li>
          <li>Step 2: Filtering Unique and Relevant Entities</li>
          <li>Step 3: Toggle ESP</li>
          <li>Step 4: Loop Through Entities and Get Screen Positions</li>
          <li>Step 5: Drawing Snaplines Using ImGui</li>
          <li>TL;DR of the Code Flow</li>
        </ul>
      </li>
      <li><a href="../part-7-final-esp/#closing-thoughts">Closing Thoughts</a></li>
    </ul>
  </li>
</ul>

<p><strong>What it should look like:</strong></p>

<h2><img src="/ViewProj-Blog/assets/images/part-1/GotEsp-1.png" alt="ESP-Image1" /></h2>
<p><img src="/ViewProj-Blog/assets/images/part-1/GotEsp-2.png" alt="ESP-Image2" /></p>

<p>Snippets of what we will be working with:</p>

<p><strong>IDA PRO:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/ida-view.png" alt="IDA-screenshot" /></p>

<p><strong>Cheat Engine:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/CheatEngine-view.png" alt="CheatEngine-screenshot" /></p>

<p><strong>Visual Studio:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/VisualStudio-view.png" alt="VisualStudio-screenshot" /></p>

<p><strong>Reclass:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/Reclass-view.png" alt="Reclass-screenshot" /></p>

<p>This blog series is just me sharing what I’ve figured out so far while reverse engineering <em>Ghost of Tsushima</em>. There’s always more to understand, and I’m sure some things I say might not be 100% perfect, so if you spot something I missed, or you have better insights, I’d really love to hear from you.</p>

<p>Feel free to reach out to me:</p>
<ul>
  <li>Discord: zer0_1rp</li>
  <li>Email: <a href="mailto:Zer0_1rp@proton.me">Zer0_1rp@proton.me</a></li>
  <li>Reddit: u/zer0_1rp</li>
  <li>UC: z1rp</li>
</ul>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[⚠️ Disclaimer: The content on this blog is provided for educational and informational purposes only. I do not encourage, endorse, or support any illegal activity. Any techniques, tools, or concepts discussed are intended solely for learning, research, defensive security, or experimentation in safe, legal environments. Use this information responsibly and at your own risk. The author is not responsible for any misuse or legal consequences that may result from applying what’s written here.]]></summary></entry><entry><title type="html">Part 2.1: View Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix/" rel="alternate" type="text/html" title="Part 2.1: View Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix/"><![CDATA[<h3 id="introduction"><strong>Introduction</strong></h3>

<p>In 3D computer graphics, transformation matrices are the behind-the-scenes math that turns 3D world into something that actually 
shows up on your 2D screen. Three particularly important matrices work together to take 3D world coordinates and transform them into 2D screen coordinates: the 
View Matrix, Projection Matrix, and their combination, the View Projection Matrix</p>

<h3 id="camera-world-matrix"><strong>Camera World Matrix</strong></h3>

<p>Before jumping into the view matrix we first have to know about the camera world matrix and its relation with the view matrix
(some people refer to it by different names, but I’ll just call it the <em>camera world matrix</em>)</p>

<p>The camera world matrix is basically the camera’s own transform. It describes how the
camera is oriented and positioned in world space</p>

<p>It usually looks like this (in row-major form):</p>

<table>
  <tbody>
    <tr>
      <td>right.x</td>
      <td>right.y</td>
      <td>right.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>up.x</td>
      <td>up.y</td>
      <td>up.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Forward.x</td>
      <td>Forward.y</td>
      <td>Forward.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>pos.x</td>
      <td>pos.y</td>
      <td>pos.z</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>Position Vector:
The position of the camera ‘(x,y,z)’ in world space.</p>

<p>we will discuss the right/up/forward vectors in the View Matrix segment and later how this layout differs from Ghost of Tsushima.</p>

<h3 id="what-is-a-view-matrix"><strong>What is a View-Matrix?</strong></h3>

<p>The <em>view matrix</em> is a 4x4 matrix that transforms coordinates from world space into view (or camera) space. It does <strong>not</strong> tell us where the camera is,
that’s what the camera world matrix is for. Instead, the view matrix takes everything in the world and repositions it relative to the camera, 
as if the camera is sitting at the origin (0, 0, 0) and looking straight down its forward axis.</p>

<blockquote>
  <p>world space -&gt; view space</p>
</blockquote>

<p>So in a sense, it’s not the camera that moves but it’s the world that shifts and rotates around the camera</p>

<blockquote>
  <p>The view matrix is just the inverse of the camera world matrix.<br />
Since the camera world matrix places the camera in the world, its inverse effectively ‘un-places’ the world relative to the camera, resulting in the view matrix.</p>
</blockquote>

<hr />

<h3 id="layout-of-the-view-matrix"><strong>Layout Of the View Matrix</strong></h3>

<p>Here is a row-major, left-handed layout of how the <em>View Matrix</em> looks like</p>

<table>
  <tbody>
    <tr>
      <td>Right.x</td>
      <td>Up.x</td>
      <td>Forward.x</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Right.y</td>
      <td>Up.y</td>
      <td>Forward.y</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Right.z</td>
      <td>Up.z</td>
      <td>Forward.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>-dot(Right, Position)</td>
      <td>-dot(Up, Position)</td>
      <td>-dot(Forward, Position)</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This layout isn’t a hard rule, it can change depending on things like whether the engine uses a right-handed or left handed coordinate system, whether it stores matrices in row-major or column-major order, or even custom layouts used for optimization. What matters is consistency: as long as the engine expects that specific layout, it will work. But no matter how it’s arranged, the matrix still needs the same essential components: Right, Up, Forward, and Translation.</p>
</blockquote>

<p>This 4x4 Matrix layout is common in DirectX Games where it is usually row-major and left-handed.<br />
This <em>View Matrix</em> is made up of 4 fundamental vectors:</p>
<ul>
  <li><strong>Right Vector</strong>:  which direction is right from the camera’s perspective</li>
  <li><strong>Up Vector</strong>: which direction is up from the camera’s perspective</li>
  <li><strong>Forward Vector</strong>: which direction the camera is facing</li>
  <li><strong>Translation Vector</strong>: The component that translates the world to the camera’s origin</li>
</ul>

<p>Before diving into the fundamental vectors, let’s take a moment to understand row vs. column major order and left- vs. right-handed coordinate systems:</p>

<ul>
  <li><strong>Row-Major</strong>:
The matrix is constructed row by row.</li>
  <li><strong>Column-Major</strong>:
The Matrix is constructed column by column.</li>
</ul>

<blockquote>
  <p>Eg: The right Vector would have occupied the first row in row-major Matrix but the first column in column-major Matrix.</p>
</blockquote>

<ul>
  <li><strong>Left-Handedness:</strong>
+Z points into the screen.</li>
  <li><strong>Right-Handedness:</strong>
+Z points out of the screen.</li>
</ul>

<blockquote>
  <p>This is why in Right-Handed systems the forward Vector will be <em>negated</em>.</p>
</blockquote>

<h3 id="breaking-down-the-view-matrix-vectors"><strong>Breaking Down the View Matrix Vectors</strong></h3>

<p>The Right, Up and Forward vectors in your matrix define the orientation of an object or camera in 3D space.</p>

<p><strong>Right Vector (X-axis):</strong><br />
The Right vector is a directional vector that points to the right-hand side of the camera in the camera’s local space.
It Defines the camera’s local X-axis</p>

<p><strong>Up Vector (Y-axis):</strong><br />
This is also a directional Vector but points toward the top side of the camera. It points straight up from the camera’s perspective.
It defines the camera’s local Y-axis</p>

<p><strong>Forward Vector:</strong><br />
This Vector points in the direction the camera is facing. (Where the camera is looking at)
It defines the camera’s local Z-axis</p>
<blockquote>
  <p>The forward vector direction is typically (LookAtTarget - CameraPosition).normalized() for Left-Handed systems like Direct-X but for right-handed systems
the view matrix uses the negative Z-axis, which would be (CameraPosition - LookAtTarget).normalized().</p>
</blockquote>

<p>The components of orientation vectors (Right, Up, Forward) will always be in the range of -1.0 to 1.0.</p>

<p><strong>Translation Vector:</strong><br />
This translation vector basically tells the view matrix how to undo the camera’s position and orientation so that the world moves around the camera and not the other way around.
This is derived from a dot product between the orientation vectors and the camera’s position.
In the view matrix, this position is negated to move the world around the camera.</p>

<h3 id="orthogonality-and-relations--optionalgood-to-know"><strong>Orthogonality and Relations:- (Optional/Good to know)</strong></h3>

<p>For a camera to behave properly in 3D space, its orientation vectors (Right, Up, Forward) must be orthogonal (Perpendicular) to each other. <br />
In Vector Algebra we know 2 perpendicular vector’s dot product is always 0.</p>
<blockquote>
  <p>Thus:<br />
dot(Right, Up) = 0<br />
dot(Up, Forward) = 0<br />
dot(Forward, Right) = 0</p>
</blockquote>

<p>In vector algebra, we also have the cross product and the right-hand rule, which states:  <br />
The cross product of two vectors “A” and “B” results in a new vector (C = A x B). This resultant vector “C” is always perpendicular (orthogonal) 
to both original vectors “A” and “B”.</p>
<blockquote>
  <p>Thus:<br />
cross(Up, Right) = Forward<br />
cross(Right, Forward) = Up<br />
cross(Forward, Up) = Right<br />
(For Left-Handed systems)</p>
</blockquote>

<p>This returns a new vector perpendicular to the two input vectors. This relationship ensures all three orientation axes form a proper 
coordinate system</p>

<h3 id="model-matrix--optionalgood-to-know"><strong>Model Matrix:- (Optional/Good to know)</strong></h3>

<p>Before we move forward, it’s worth mentioning the Model Matrix<br />
The Model Matrix is defined by an object’s position, rotation, and scale. It transforms the object’s vertices from their local model space into world space. The X,Y,Z coordinates of 
these vertices are defined relative to the object’s center, This Matrix is responsible for transforming a 3D model from its local space into world space handling the model’s 
position, rotation and scale.</p>

<blockquote>
  <p>Model space -&gt; World space</p>
</blockquote>

<p>For the purpose of world-to-screen projection (basic ESP overlay), we don’t actually need the model matrix.<br />
<strong>Why?</strong><br />
The esp we are building only needs to know where something is in world space and the game has already computed and placed the model in world space.
Since the model matrix just moves the object from local space to world space, and we already have the world position, it becomes redundant in this
context.<br />
We don’t use this, but it’s worth knowing because the Camera World Matrix we discussed earlier is just a special case of a Model Matrix: it represents the 
camera’s position and orientation in world space, just like a model matrix does for any object.</p>
<blockquote>
  <p>Quick Note:
While a model matrix typically includes rotation, translation, and scale, the camera world matrix only includes rotation and translation.
Structurally, they share the same layout, the camera world matrix is essentially a model matrix for the camera itself.</p>
</blockquote>

<p><strong>If you want to learn more about model, view and projection matrices you can check out this OpenGL tutorial and this video which i found informative 
explaining the math behind matrices and 3d graphics theory:</strong><br />
<a href="https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices">OpenGL tutorial</a><br />
<a href="https://www.youtube.com/watch?v=wiYTxjJjfxs">In Video Games, The Player Never Moves</a></p>

<p><em>All of these mathematical relationships, spatial orientations, and foundational concepts might seem unnecessary but they are crucial. We’ll
rely on this knowledge to accurately identify the different matrices in memory, decode how the game constructs them, and understand exactly
how the camera views the world.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Part 2.2: Projection Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix/" rel="alternate" type="text/html" title="Part 2.2: Projection Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix/"><![CDATA[<h3 id="what-is-the-projection-matrix"><strong>What is the Projection Matrix?</strong></h3>

<p>While the View Matrix transforms world coordinates into the camera’s local space, the Projection Matrix transforms that 3D camera space into a clipped 2D space.<br />
This is the step where perspective is introduced where far objects look smaller, and near objects look larger.</p>
<blockquote>
  <p>view space -&gt; clip space</p>
</blockquote>

<p>The projection matrix defines how the 3D scene (Game) is projected onto a 2D surface (Your screen).<br />
It Determines:</p>
<ul>
  <li>What part of the world is visible through the camera (field of view).</li>
  <li>How deep the camera can see (near/far clipping planes).</li>
  <li>How the perspective distortion should look (objects farther away appear smaller etc…)</li>
  <li>Defines the 3D view Frustum</li>
</ul>

<p>There are two main types of projection matrices</p>
<ul>
  <li><strong>Perspective Projection</strong></li>
  <li><strong>Orthographic Projection</strong></li>
</ul>

<p>Here we will only be looking at the Perspective Projection Matrix.</p>

<h3 id="what-the-projection-matrix-does"><strong>What the Projection Matrix Does:</strong></h3>

<p>The projection matrix transforms view space into clip space. The graphics pipeline then performs the perspective divide (dividing by w) to convert clip space into Normalized 
Device Coordinates (NDC).<br />
In NDC (for DirectX):</p>
<ul>
  <li>The x and y coordinates are squeezed into the range −1 to +1, and the z coordinate is squeezed into the range 0 to +1.</li>
  <li>Everything inside this cube is visible.</li>
  <li>Everything outside is clipped (not rendered).</li>
</ul>

<p>The <em>Projection Matrix</em> represents how the camera sees. It gives the world its sense of depth and perspective, and its parameters:
FOV, aspect ratio, near and far planes define the visible 3D frustum.</p>

<h3 id="layout-of-the-perspective-projection-matrix"><strong>Layout of the Perspective Projection Matrix</strong></h3>

<p>Here is the standard layout of a perspective projection matrix (DirectX):</p>

\[P =
\begin{bmatrix}
x_{scale} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; y_{scale} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \dfrac{z_{far}}{z_{far} - z_{near}} &amp; 1 \\
0 &amp; 0 &amp; -\dfrac{z_{near} \cdot z_{far}}{z_{far} - z_{near}} &amp; 0
\end{bmatrix}\]

<p>Lets breakdown all the parameters:</p>

<ul>
  <li><strong>zNear:</strong> Near clip plane</li>
  <li><strong>zFar:</strong> Far clip plane</li>
  <li>
    <p><strong>xScale:</strong><br />
\(x_{scale} = \frac{1}{\tan{\left(\frac{Fov_X}{2}\right)}}\)</p>
  </li>
  <li>
    <p><strong>yScale:</strong><br />
\(y_{scale} = \frac{1}{\tan{\left(\frac{Fov_Y}{2}\right)}}\)</p>

    <p>or equivalently,<br />
\(y_{scale} = \frac{1}{AspectRatio \cdot \tan{\left(\frac{Fov_X}{2}\right)}}\)</p>
  </li>
</ul>

<p><em>For a deep dive and visual derivation of how these parameters (FOV, Aspect Ratio, Near/Far planes) determine each element of the Perspective Projection Matrix check out this video by 
by pikuma.</em><br />
<a href="https://www.youtube.com/watch?v=EqNcqBdrNyI">Perspective Projection Matrix (Math for Game Developers)</a></p>

<h3 id="relationship-between-horizontal-and-vertical-fov"><strong>Relationship Between Horizontal and Vertical FOV</strong></h3>

<p>Let A denote the Aspect Ratio, defined as</p>

\[A = \text{AspectRatio} = \frac{\text{Width}}{\text{Height}}\]

<p>The relationship between \(FOV_x\) and \(FOV_y\) is:</p>

\[\tan\left(\frac{FOV_X}{2}\right) = A \cdot \tan\left(\frac{FOV_Y}{2}\right)\]

<p>From this, we can express each one in terms of the other:</p>

\[FOV_X = 2 \cdot \tan^{-1}\!\left(A \cdot \tan\!\left(\frac{FOV_Y}{2}\right)\right)\]

\[FOV_Y = 2 \cdot \tan^{-1}\!\left(\frac{\tan\!\left(\frac{FOV_X}{2}\right)}{A}\right)\]

<p><em>If you want to learn how these formulas are derived i recommand this write-up by Wojtek Sterna:</em><br />
<a href="https://wojtsterna.com/2024/01/09/field-of-view-horizontal-and-vertical-conversion/">Field of View – Horizontal and Vertical Conversion</a></p>

<h3 id="what-is-reverse-z"><strong>What is Reverse Z?</strong></h3>

<p>Since this game uses the Reverse Z technique for its projection matrix, i will quickly explain what it is:</p>

<p>Reverse Z is a trick used in modern engines to fix depth precision issues. Normally, the projection matrix maps the near plane to 0.0 and the far plane to 1.0, but that 
causes most of the precision to get crammed near the camera. The farther the objects go, the less depth precision they get, which leads to Z-fighting, basically, two surfaces 
fighting to render because their depth values end up almost identical.</p>

<p>Reverse Z simply flips this, the near plane becomes 1.0 and the far plane becomes 0.0. That way you get way better precision at far distances.</p>

<p>This works because floating-point values are denser near zero, so by reversing the range, the GPU distributes precision where it’s actually needed which is for objects 
farther away, not just right in front of the camera.</p>

<h3 id="layout-of-reverse-z-projection-matrix"><strong>Layout of Reverse Z Projection Matrix</strong></h3>

\[P =
\begin{bmatrix}
x_{scale} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; y_{scale} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -\dfrac{z_{near}}{z_{far} - z_{near}} &amp; 1 \\
0 &amp; 0 &amp; \dfrac{z_{far} \cdot z_{near}}{z_{far} - z_{near}} &amp; 0
\end{bmatrix}\]

<ul>
  <li>Swapped far to negative near for numerator at m22</li>
  <li>Fliped signs for numerator at m32</li>
</ul>

<blockquote>
  <p>This is the specific layout of the projection matrix used in Ghost of Tsushima, this is not an absolute layout for reverse-Z.<br />
What defines a Reverse-Z projection is simply the depth mapping after the perspective divide:</p>
  <ul>
    <li>near → 1</li>
    <li>far → 0</li>
  </ul>

  <p>As long as this mapping holds true, it qualifies as Reverse-Z.</p>
</blockquote>

<p><em>We’ll later see how this matrix fits into the full pipeline and how the 3D position finally lands on your screen.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[What is the Projection Matrix?]]></summary></entry><entry><title type="html">Part 2.3: View Projection Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.3-View-Projection-matrix/" rel="alternate" type="text/html" title="Part 2.3: View Projection Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.3-View-Projection-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.3-View-Projection-matrix/"><![CDATA[<h3 id="what-is-the-view-projection-matrix"><strong>What is the View-Projection Matrix?</strong></h3>

<p>The View-Projection Matrix (VP Matrix) is just the View Matrix and Projection Matrix multiplied together:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ViewProjection</span> <span class="o">=</span> <span class="n">Projection</span> <span class="o">*</span> <span class="n">View</span>  
</code></pre></div></div>
<blockquote>
  <p>Note: Matrix multiplication is not commutative:- A * B ≠ B * A<br />
The multiplication order depends on the graphics system, influenced by its row/column major layout and handedness.</p>
</blockquote>

<p>This combined matrix allows you to transform a world-space position directly into clip space in one step. Instead of first 
applying the view matrix, then the projection matrix separately, both transformations are handled at once:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clipSpacePos</span> <span class="o">=</span> <span class="n">worldSpacePos</span> <span class="o">*</span> <span class="n">ViewProjection</span>
</code></pre></div></div>

<p>That takes a position straight from world space into clip space. Because this matrix is used constantly, 
most engines just precompute it once per frame and cache it in memory.</p>

<p>Even though it’s “just” the product of two matrices, the VP Matrix is the one that usually gets used the most, it represents the 
full world-to-clip transformation and decides what actually shows up on screen.</p>

<p><em>For a comprehensive, detailed breakdown of the entire transformation chain (Model, World, View, and Projection),  i  highly recommended this article by Marco Alamia:</em><br />
<a href="http://www.codinglabs.net/article_world_view_projection_matrix.aspx">World, View and Projection Transformation Matrices</a></p>

<p><em>This is all we’ll cover about the View-Projection matrix for now. The goal isn’t to dive deep into 3D rendering, but to build a clear, 
working understanding of how it functions at a basic level.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[What is the View-Projection Matrix?]]></summary></entry><entry><title type="html">Part 3: Finding &amp;amp; Reversing Matrices</title><link href="http://localhost:4000/ViewProj-Blog/part-3-finding-and-reversing-matrices/" rel="alternate" type="text/html" title="Part 3: Finding &amp;amp; Reversing Matrices" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-3-finding-and-reversing-matrices</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-3-finding-and-reversing-matrices/"><![CDATA[<h3 id="how-we-search-for-matrices-in-memory"><strong>How We Search for Matrices in Memory</strong></h3>

<p>A common approach is to switch Cheat Engine’s value type in <em>float</em> and then:</p>

<ol>
  <li>Look Directly up and scan for the value <em>1.0f</em>.</li>
  <li>Look Directly Down and scan for the value <em>-1.0f</em>.</li>
  <li>Rescan to narrow the matrices down to matrices that are actively changing with camera orientation.</li>
</ol>

<p>Once you narrow it down, you can inspect nearby memory regions and layout patterns (like a 4x4 float matrix) to identify which matrix it is</p>

<p>This technique works because these matrices are often stored in memory in a row-major or column-major 4x4 float array, and the directional 
vectors (Right, Up, Forward) reflect real-time camera movement</p>

<blockquote>
  <p>Basically Something in the matrix must encode the camera’s up/down rotation</p>
</blockquote>

<h3 id="searching-for-matrices-in-ghost-of-tsushima"><strong>Searching for Matrices in Ghost of Tsushima</strong></h3>

<p>Lets start searching for interesting matrices in memory in ghost of tsushima!</p>

<p><strong>Looking up in game</strong>
<img src="/ViewProj-Blog/assets/images/part-3/look-up-got.png" alt="ESP-Image1" /></p>

<p><strong>Seraching for 1.0f in cheat engine</strong>
<img src="/ViewProj-Blog/assets/images/part-3/ce-first-scan.png" alt="ESP-Image1" /></p>

<p><strong>Now looking Down</strong>
<img src="/ViewProj-Blog/assets/images/part-3/look-down-got.png" alt="ESP-Image1" /></p>

<p><strong>Searching for -1.0f in cheat engine</strong>
<img src="/ViewProj-Blog/assets/images/part-3/ce-second-scan.png" alt="ESP-Image1" /></p>

<p>Now you’re going to get a lot of results. Keep refining your search (e.g., by changing camera angles and scanning again) until the 
number of results stabilizes and stops changing, that’s usually a good sign you’ve isolated the relevant addresses.</p>

<p>Now when reverse engineering a game, you’ll often find that the View, Projection, and View-Projection matrices (mostly) live at fixed or static memory addresses.<br />
<strong>Why?</strong><br />
Mainly because these matrices are core components of the game’s rendering pipeline and are global to the camera or render context.</p>

<p>Now we can add all static memory address’s and browse its memory layout’s to see if we find some interesting matrices.</p>

<p><strong>Like Here:</strong>
<img src="/ViewProj-Blog/assets/images/part-3/cam-world-matrix-and-view-matrix.png" alt="ESP-Image1" /></p>

<p>Here the first 4x4 matrix look like the <em>Camera World Matrix</em> and the second 4x4 matrix looks like the <em>View Matrix</em>.</p>

<h3 id="confirmation-of-the-view-and-camera-world-matrices"><strong>Confirmation of the View and Camera World Matrices:</strong></h3>

<p>In <a href="../part-2.1-view-matrix/#orthogonality-and-relations--optionalgood-to-know">Part 2.1: View Matrix</a> we talked about the orthogonality and relations of the fundamental Vectors.<br />
Let’s open these matrices in reclass and use these relations to confirm it!</p>

<p>Lets form an Hypothesis that this is the layout of the 4x4 Matrix:
<img src="/ViewProj-Blog/assets/images/part-3/reclass-view-cam-hypothesis.png" alt="ESP-Image1" /></p>

<p>Using its relations we can see:</p>
<ul>
  <li>Dot((-0.104, -0.06, 0.993), (0.5, -0.866, 0.00)) = <em>-3.9999999999998E-5</em> which is basically just <em>0</em> and is just floating-point precision error.</li>
  <li>Cross((-0.104, -0.06, 0.993), (0.5, -0.866, 0.00)) = <em>(0.860, 0.496, 0.121)</em> which basically gave us the second row (starting row’s from 0)</li>
</ul>

<blockquote>
  <p>This is handy in reverse engineering because you can’t always hope to stumble upon a perfect, clean 4×4 matrix in memory. Sometimes you’ll just find a couple 
of direction vectors (like Right and Up) sitting in random spots or being passed into a function. With some quick vector math, you can fill 
in the missing one using a cross product, or sanity-check them with a dot product (should be zero if they’re perpendicular). That way, even 
if the layout is weird or partially obfuscated, you can still piece it together.<br />
Also Handy if you are not sure if this ViewMatrix is not altered in any way eg: Its the Model-View Matrix.</p>
</blockquote>

<p>If the values are orthogonal, have unit lengths, include a clear translation component (usually the bigger numbers &gt; 1.0f), and end with the homogeneous 
coordinate row or column [0, 0, 0, 1], you can be pretty sure it’s a real transformation matrix.</p>

<blockquote>
  <p>To be extra sure, don’t just trust the layout you find. The 0th row isn’t always Right and the last row isn’t always Translation. It’s usually 
textbook layout in most games, but not always. Move the camera around and watch which parts of the matrix change. Let the behavior tell you what’s what.</p>
</blockquote>

<p><strong>Lets now inverse it to get the view matrix:</strong>
<img src="/ViewProj-Blog/assets/images/part-3/cam-world-inverse.png" alt="ESP-Image1" /></p>

<p>We can see it exactly matches the second 4x4 matrix we see in memory (Camera World Matrix (Inverse) = View Matrix).</p>

<blockquote>
  <p>We can also take dot(Right, Pos) and compare it against the translation component of the second matrix as another way to confirm this relationship.</p>
</blockquote>

<p>Thus pretty much confirming the first matrix to be <em>Camera World Matrix</em> and the second matrix to be the <em>View Matrix</em>.</p>

<h3 id="looking-at-other-matrices"><strong>Looking at other matrices</strong></h3>

<p>Here we see some other matrices:
<img src="/ViewProj-Blog/assets/images/part-3/reclass-view-projection-matrix.png" alt="ESP-Image1" /></p>

<p>The first matrix clearly resembles a projection matrix, but in this case, it uses a reverse-Z projection setup meaning the depth range is inverted so that the near plane maps to 1.0 
and the far plane maps to 0.0.</p>

<p>The second matrix appears to be the View-Projection (VP) matrix, produced by multiplying the Projection and View matrices together.</p>

<p>The third matrix appears to be the View-Projection matrix but with the translation component zeroed out.</p>

<p><strong>Why?</strong><br />
Because they fit the general layout’s expected of these matrices.<br />
To be sure lets plug in the view projection matrix into a world to screen function to see if we can confirm this.</p>

<p>To verify i will manually input the entity coordinates into my world to screen program.<br />
Here is the entity whose position we’ll convert:<br />
<img src="/ViewProj-Blog/assets/images/part-3/view-proj-test-in-game.png" alt="ESP-Image1" /></p>

<p>Since this image shows that the entity is at the top-left corner of our screen at a resolution of 1920x1080 we can expect the screen coordinates to
be close to (0, 0) since the Top-left corner is the origin of the screen (0, 0), not bottom left as you might expect (unlike OpenGL).<br />
<img src="/ViewProj-Blog/assets/images/part-3/view-proj-screen-pos-results.png" alt="ESP-Image1" /></p>

<p>Here we can see the output screen coordinates matches closely to what we expected.</p>

<p>We’ll cover how to get the entity’s 3D coordinates and how World-to-Screen works in detail later, for now, this confirms the matrix is correct.</p>

<blockquote>
  <p>Quick Note: The top left is (0,0) for Direct-X in the context of Screen Space Coordinates but for Normalized Device Coordinates (NDC) the center of the screen is (0,0) and the 
top left would be (-1,1).</p>
</blockquote>

<h2 id="other-ways-to-get-the-vp-matrix"><strong>Other ways to get the VP matrix</strong></h2>

<p>You don’t have to rely on pure luck to find the VP matrix. Instead of just stumbling across it, you can track it down by first finding the 
camera world matrix, view matrix, or projection matrix, then checking which functions access these matrices.</p>

<p>When digging through those functions in IDA, look for clues like:</p>

<ul>
  <li>Expected function arguments: e.g., does the function take both a View Matrix and a Projection Matrix?</li>
  <li>SIMD-heavy math patterns: Does the function use SIMD math for matrix multiplication?</li>
  <li>Matrix usage: Which matrices does it load for its calculations?</li>
  <li>Inverse operations: Is it inverting the camera world matrix at any point?</li>
</ul>

<p><strong>Example:</strong></p>

<p>I used this method to identify the VP matrix construction function in a Denuvo protected game, Ghost Recon Wildlands. I looked at what 
accessed the projection matrix and found the function that builds the VP matrix.</p>

<p><img src="/ViewProj-Blog/assets/images/part-3/got_esp1.png" alt="ESP-Image1" />
<img src="/ViewProj-Blog/assets/images/part-3/GRWESP1.gif" alt="ESP-Image1" /></p>

<p>Dealing with Denuvo’s anti-reverse engineering tricks and other protections felt like i was doing a lobotomy speedrun any%.<br />
If you ever want to test your sanity, try reversing a Denuvo game.</p>

<h2 id="trying-to-rebuild-the-view-projection-matrix"><strong>Trying to Rebuild the View-Projection Matrix</strong></h2>

<p>Now that we have confirmed that this is in fact the view projection matrix lets try to reconstruct it manually</p>

<ol>
  <li>Take the inverse of the Camera World Matrix</li>
  <li>Multiply it with the suspected Projection Matrix</li>
</ol>

<p><img src="/ViewProj-Blog/assets/images/part-3/discrepency-vp-with-vp-multiply.png" alt="ESP-Image1" /><br />
Here for some reason it doesn’t quite match’s up although quite similar.</p>

<p><em>Next Step: Time to start tracing back the functions that write to the final View-Projection Matrix in memory.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[How We Search for Matrices in Memory]]></summary></entry><entry><title type="html">Part 4.1: Tracing the Matrix Construction Path</title><link href="http://localhost:4000/ViewProj-Blog/part-4.1-tracing-matrix-construction/" rel="alternate" type="text/html" title="Part 4.1: Tracing the Matrix Construction Path" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-4.1-tracing-matrix-construction</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-4.1-tracing-matrix-construction/"><![CDATA[<style>
.ida-code{
  background:#1e1e1e;
  color:#dcdcdc;
  padding:12px;
  border-radius:8px;
  font-family: Consolas, "Liberation Mono", Menlo, monospace;
  font-size:14px;
  line-height:1.4;
  overflow-x:auto;
  white-space: pre; /* preserve spaces and linebreaks */
}

/* token classes you can use inside the div */
.ida-code .kw    { color:#569cd6; } /* keywords */
.ida-code .type  { color:#4ec9b0; } /* types */
.ida-code .fn    { color:#dcdcaa; } /* functions / intrinsics */
.ida-code .num   { color:#b5cea8; } /* numbers / hex */
.ida-code .var   { color:#9cdcfe; } /* variables */
.ida-code .const { color:#ce9178; } /* globals / constants */
.ida-code .comment{ color:#6a9955; font-style:italic; }
</style>

<h3 id="tracing-functions-writing-to-the-view-projection-matrix">Tracing Functions Writing to The View-Projection Matrix</h3>

<p>Lets start by observing which function writes to the View-Projection Matrix by clicking on the “Find out what writes this address” on the first element
of the View-Projection Matrix.</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.1/find-what-writes-vpmatrix.png" alt="ESP-Image1" /></p>

<p>We have found 2 different functions that seem to write to this address.
<img src="/ViewProj-Blog/assets/images/part-4.1/found-what-writes-vpmatrix.png" alt="ESP-Image1" /></p>

<p>The first instruction seems to reference an address “VCRUNTIME140.memset+134:” and the second one references “GhostOfTsushima.exe+9AA0AF:”.<br />
The second instruction intrigues me more so lets look at that one.<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/9aa082-ins-asm-ce.png" alt="ESP-Image1" /></p>

<p>Here [rdi+0x5C0] is our static memory address of the view projection matrix and is getting written into by “xmm0”.</p>

<blockquote>
  <p>On x64, you’ll often see xmm0–xmm15 in the disassembly. These are 128-bit registers the CPU uses for SIMD (“Single Instruction, Multiple Data”) work, 
basically crunching multiple floats at once (4-32bit floats). Games use these for stuff like matrix math, vector transforms, and physics, 
because it’s faster than doing one number at a time.</p>
</blockquote>

<p>Lets now see where “xmm0” gets its 4, 32bit float values from. In the instruction just above we see “xmm0” gets its value from<br />
“movups xmm0,[rax+00000240]” which means [rax+00000240] would be where it seems to copy the values from.</p>

<p><strong>lets see this entire function in IDA before moving further</strong></p>

<p>lets “select current function” in cheat engine to get the function start address which is “GhostOfTsushima.exe+9AA040”.<br />
Lets put this in IDA and see its pseudo-code.
<img src="/ViewProj-Blog/assets/images/part-4.1/ida-view-9aa082.png" alt="ESP-Image1" /></p>

<blockquote>
  <p>Don’t forget to rebase IDA to “0” before searching for the address in the function sub-view!<br />
Alternatively, you can calculate the offset between the Cheat Engine base and the IDA base manually using a calculator.</p>
</blockquote>

<p>While stepping through the function, I didn’t encounter many SIMD instructions like “mm_mul”, “mm_add_ps”, or “mm_shuffle_ps” (only a few).
Instead, it appears that the function is primarily copying matrices from dynamic memory into this static location,  possibly from a 
camera struct or a similar source.</p>

<p>Let’s now see what function writes to the dynamic address that its copying from - ([rax+0x240]):
<img src="/ViewProj-Blog/assets/images/part-4.1/matrix-copy-ins-write.png" alt="ESP-Image1" /></p>

<p>We can see one instruction reference “GhostOfTsushima.exe+7FC11B:”. Let’s select the current function and plug it into ida to see its pseudo code.</p>

<div class="ida-code"><span class="kw">char</span> <span class="kw">__fastcall</span> <span class="fn">sub_7FBF10</span>(<span class="type">__int64</span> <span class="var">a1</span>, <span class="type">__m128</span> *<span class="var">a2</span>, <span class="type">__m128</span> *<span class="var">a3</span>)
{
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x550</span>) = *<span class="var">a2</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x430</span>) = *<span class="var">a3</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x440</span>) = <span class="var">a3</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x450</span>) = <span class="var">a3</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x460</span>) = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="fn">sub_938210</span>(<span class="var">a3</span>, <span class="var">a1</span> + <span class="num">0x4B0</span>);
  <span class="var">result</span> = <span class="fn">_mm_movemask_ps</span>(<span class="fn">_mm_cmplt_ps</span>(*(<span class="type">__m128</span> *)<span class="fn">sub_7CD6F0</span>(&amp;<span class="var">v21</span>, <span class="var">a1</span> + <span class="num">0x430</span>), (<span class="type">__m128</span>)<span class="num">0LL</span>)) == <span class="num">15</span>;
  *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>) = <span class="var">result</span>;
  <span class="var">v7</span> = <span class="var">a3</span>[<span class="num">1</span>];
  <span class="var">v8</span> = *<span class="var">a3</span>;
  <span class="var">v9</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">a2</span>));
  <span class="var">v10</span> = <span class="var">a3</span>[<span class="num">2</span>];
  <span class="var">v11</span> = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v14</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v9</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v15</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v16</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v14</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v14</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
            <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">170</span>), <span class="var">v10</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">255</span>), <span class="var">v11</span>));
  <span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0</span>), *<span class="var">a3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">85</span>), <span class="var">v7</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">255</span>), <span class="var">v11</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(..............
</div>

<blockquote>
  <p>This is just a snippet of the start of the function.</p>
</blockquote>

<h3 id="windows-calling-conventions-abi">Windows Calling Conventions (ABI)</h3>

<p>On Windows x64, functions follow the Microsoft x64 calling convention. That means the first four parameters are passed in registers:</p>

<ul>
  <li>RCX → first argument (a1)</li>
  <li>RDX → second argument (a2)</li>
  <li>R8 → third argument (a3)</li>
  <li>R9 → fourth argument (a4)</li>
</ul>

<p>If there are more than four, the extras get pushed onto the stack. The return value usually ends up in RAX.</p>

<p>So if we see a function labeled with a1, a2, a3, those are just the values RCX, RDX, and R8 were holding when the function was called.</p>

<h3 id="breakpoint--stacktrace">Breakpoint &amp; Stacktrace</h3>

<p>To figure out exactly what’s being passed in, we can set a breakpoint right at the start of the function in Cheat Engine, then check those registers. 
That’ll give us a live snapshot of the arguments 
<img src="/ViewProj-Blog/assets/images/part-4.1/ce-7fbf10-breakpoint.png" alt="ESP-Image1" /></p>

<p>For now, the only argument of interest is a1, which corresponds to RCX. In this particular call, RCX = 0x2D72494D200.<br />
I consider it “interesting” because of the following code snippet inside sub_7FBF10:</p>

<div class="ida-code">  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x550</span>) = *<span class="var">a2</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x430</span>) = *<span class="var">a3</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x440</span>) = <span class="var">a3</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x450</span>) = <span class="var">a3</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x460</span>) = <span class="var">a3</span>[<span class="num">3</span>];
</div>
<p>looking through the function we notice that it loads a single 4x4 matrix and a Vector4 near the start.<br />
Let’s inspect the values at those offsets in memory.<br />
At [a1 + 0x430], we find what appears to be a ViewProjection matrix without the translation component:<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/reclass-view-proj-no-trans.png" alt="ESP-Image1" /></p>

<p>And at [a1 + 0x550], we find a Vector4 that corresponds to the camera position: <br />
<img src="/ViewProj-Blog/assets/images/part-4.1/reclass-cam-pos.png" alt="ESP-Image1" /></p>

<p>Since this function receives the view-projection matrix (without translation) as input, we can reasonably guess that the actual 
multiplication of the View and Projection matrices happens somewhere earlier in the call stack. this function isn’t building the full VP 
matrix from scratch, it’s taking an intermediate version and adding the translation part to make the final matrix the renderer uses.</p>

<blockquote>
  <p>We’ll break down this function in detail later, but for now, our goal is to trace the data flow further upstream to locate where 
this matrix begins its construction.</p>
</blockquote>

<p>Let’s breakpoint at the start of the function and use the “stack trace” feature in cheat engine.<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/ce-stack-trace-realfunc.png" alt="ESP-Image1" /></p>

<p>The first function is the function we are inside of.<br />
The instruction at GhostOfTsushima.exe+7FD233 belongs to the function that called our current function (0x7FBF10).</p>

<p>We’ll grab the start address of the caller and plug it inside of IDA for further analysis.</p>

<h3 id="ida-code">IDA Code:</h3>

<div class="ida-code"><span class="kw">char</span> <span class="kw">__fastcall</span> <span class="fn">sub_7FD060</span>(<span class="type">__int64</span> <span class="var">a1</span>)
{
  <span class="type">__m128</span> <span class="var">v1</span>; <span class="comment">// xmm7</span>
  <span class="type">__m128</span> <span class="var">v2</span>; <span class="comment">// xmm1</span>
  <span class="type">__m128</span> <span class="var">v3</span>; <span class="comment">// xmm6</span>
  <span class="type">__m128</span> <span class="var">v4</span>; <span class="comment">// xmm2</span>
  <span class="type">__m128</span> <span class="var">v5</span>; <span class="comment">// xmm9</span>
  <span class="type">__m128</span> <span class="var">v6</span>; <span class="comment">// xmm10</span>
  <span class="type">__m128</span> <span class="var">v7</span>; <span class="comment">// xmm13</span>
  <span class="type">__m128</span> <span class="var">v8</span>; <span class="comment">// xmm12</span>
  <span class="type">__m128</span> <span class="var">v9</span>; <span class="comment">// xmm5</span>
  <span class="type">__m128</span> <span class="var">v10</span>; <span class="comment">// xmm12</span>
  <span class="type">__m128</span> <span class="var">v11</span>; <span class="comment">// xmm5</span>
  <span class="type">__m128</span> <span class="var">v12</span>; <span class="comment">// xmm8</span>
  <span class="type">__m128</span> <span class="var">v13</span>; <span class="comment">// xmm12</span>
  <span class="type">__m128</span> <span class="var">v15</span>; <span class="comment">// [rsp+20h] [rbp-E8h] BYREF</span>
  <span class="type">__m128</span> <span class="var">v16</span>[<span class="num">4</span>]; <span class="comment">// [rsp+30h] [rbp-D8h] BYREF</span>

  <span class="var">v1</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x210</span>);
  <span class="var">v2</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x160</span>));
  <span class="var">v3</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x200</span>);
  <span class="var">v4</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x140</span>));
  <span class="var">v5</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x220</span>);
  <span class="var">v6</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x230</span>);
  <span class="var">v7</span> = <span class="fn">_mm_shuffle_ps</span>(
         *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x170</span>),
         <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_10F0E70</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x170</span>), <span class="num">160</span>),
         <span class="num">36</span>);
  <span class="var">v8</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x150</span>)));
  <span class="var">v9</span> = <span class="fn">_mm_unpackhi_ps</span>(<span class="var">v8</span>, <span class="var">v2</span>);
  <span class="var">v10</span> = <span class="fn">_mm_unpacklo_ps</span>(<span class="var">v8</span>, <span class="var">v2</span>);
  <span class="var">v11</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="var">v4</span>, <span class="num">0x24</span>), (<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>);
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v10</span>, <span class="var">v4</span>, <span class="num">0x1E</span>), (<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v10</span>, <span class="var">v4</span>, <span class="num">4</span>), (<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>);
  <span class="var">v16</span>[<span class="num">1</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0</span>), <span class="var">v3</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="var">v16</span>[<span class="num">2</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0</span>), <span class="var">v3</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="var">v16</span>[<span class="num">3</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(
                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0</span>), <span class="var">v3</span>),
                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="var">v15</span> = <span class="var">v7</span>;
  <span class="var">v16</span>[<span class="num">0</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0</span>), <span class="var">v3</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="kw">return</span> <span class="fn">sub_7FBF10</span>(<span class="var">a1</span>, &amp;<span class="var">v15</span>, <span class="var">v16</span>);
}
</div>

<p>This function takes a single argument, probably a pointer to the camera structure.<br />
Notably, it accesses two 4x4 matrices</p>

<p>[a1+0x200]:<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/a1+200-matrix.png" alt="ESP-Image1" /><br />
This is just the Projection Matrix.</p>

<p>[a1+0x140]:<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/a1+140-matrix.png" alt="ESP-Image1" /><br />
This is just the Camera World Matrix.</p>

<p>Throughout the function, we see use _mm_mul_ps, _mm_add_ps, and _mm_shuffle_ps popping up which is a indicator for SIMD matrix multiplication. 
The v16 array, which is made up of __m128 values, is gradually filled with the result of these operations, effectively forming a 4x4 matrix.</p>

<blockquote>
  <h3 id="why-not-just-invert-it">Why Not Just Invert It?</h3>
  <p>If you already have both the Projection (P) and the View-Projection (VP) matrices, you can simply compute the View-matrix (V) using <em>Matrix algebra</em>.<br />
If the game uses the row-vector convention (common in DirectX), where the order is:<br />
\(\begin{align}VP = V \times P\end{align}\) <br />
Therefore, you can solve for V:<br />
\(\begin{align} V = VP \times P^{-1}\end{align}\)<br />
If the game uses the column-vector convention (common in OpenGL), where the order is:<br />
\(\begin{align}VP = P \times V\end{align}\) <br />
Then, you can solve for V:<br />
\(\begin{align}V = P^{-1} \times VP\end{align}\)  <br />
But this lacks the insight into how the engine computes it internally, So we are going to do it the Hard Way.</p>
</blockquote>

<p><em>Now that we have confirmed that this is probably the matrix construction function of the View-Projection matrix we can now start reversing 
its many SIMD instructions to see what exactly it does with the camera world matrix and projection matrix.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Part 4.2: Reversing SIMD Instructions for Matrix Math</title><link href="http://localhost:4000/ViewProj-Blog/part-4.2-reversing-simd-instrustions/" rel="alternate" type="text/html" title="Part 4.2: Reversing SIMD Instructions for Matrix Math" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-4.2-reversing-simd-instrustions</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-4.2-reversing-simd-instrustions/"><![CDATA[<style>
.ida-code{
  background:#1e1e1e;
  color:#dcdcdc;
  padding:12px;
  border-radius:8px;
  font-family: Consolas, "Liberation Mono", Menlo, monospace;
  font-size:14px;
  line-height:1.4;
  overflow-x:auto;
  white-space: pre; /* preserve spaces and linebreaks */
}

/* token classes you can use inside the div */
.ida-code .kw    { color:#569cd6; } /* keywords */
.ida-code .type  { color:#4ec9b0; } /* types */
.ida-code .fn    { color:#dcdcaa; } /* functions / intrinsics */
.ida-code .num   { color:#b5cea8; } /* numbers / hex */
.ida-code .var   { color:#9cdcfe; } /* variables */
.ida-code .const { color:#ce9178; } /* globals / constants */
.ida-code .comment{ color:#6a9955; font-style:italic; }
</style>

<h3 id="️-note-for-readers">⚠️ Note for readers:</h3>
<p>This post is meant for intermediate to advanced readers who want to understand how low-level SIMD instructions are 
used in real-world graphics code (like game engines).<br />
That said, I’ve done my best to break things down step-by-step, even if you’re still learning, I hope parts of it are still approachable.</p>

<h3 id="reversing-simd-instructions">Reversing SIMD instructions</h3>

<p>Let’s start by dissecting the instructions in sub_7FD060 which we will rename to “ProjXViewMul” and rename the camera world matrix and 
projection matrix accessed in this function as CamWorldMat and ProjMat respectively and a1 as camStruct.</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.2/ida-view-1.png" alt="ESP-Image1" /></p>

<h2 id="masking-out-w-with-simd-theory">Masking Out w with SIMD (Theory)</h2>

<p>Let’s start with the first explanation of the SIMD instruction.<br />
The bitmask used in the instruction:</p>

<div class="ida-code"><span class="var">CamWorldMat_2</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">camStruct</span> + <span class="num">0x160</span>));
</div>

<p>relies on a clever use of NaN values as a bitmask.<br />
xmmword_1138D50 is a static memory address that holds four 32-bit floats:<br />
(NaN, NaN, NaN, 0.0f)</p>

<p>Here <strong>specfically</strong> ‘NaN’ refer to a 32 bit value where all bits are flipped to 1.<br />
<img src="/ViewProj-Blog/assets/images/part-4.2/ieee-float-binary.png" alt="ESP-Image1" /></p>
<blockquote>
  <p>NaN doesn’t literally mean “all bits 1” (0xFFFFFFFF), that’s one specific payload of NaN</p>
</blockquote>

<p>As shown above:</p>

<ul>
  <li>Exponent bits are all 1s</li>
  <li>Mantissa bits are non-zero</li>
  <li>Resulting value is NaN, but its binary pattern is ‘11111111111111111111111111111111’</li>
</ul>

<p>So, when _mm_and_ps() uses (NaN, NaN, NaN, 0.0f):</p>

<ul>
  <li>NaN &amp; X,Y,Z = X,Y,Z (because all bits are 1 → preserves input)</li>
  <li>0.0f &amp; W = 0 (because all bits are 0 → clears input)</li>
</ul>

<p>Doing this, the bitwise AND preserve x/y/z while zeroing out w.</p>

<h4 id="next-simd-instruction"><em>Next SIMD instruction.</em></h4>

<div class="ida-code">  <span class="var">CamWorldMat_3_camPos</span> = <span class="fn">_mm_shuffle_ps</span>(
         		    *(<span class="type">__m128</span> *)(<span class="var">camStruct</span> + <span class="num">0x170</span>),
         		    <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_10F0E70</span>, *(<span class="type">__m128</span> *)(<span class="var">camStruct</span> + <span class="num">0x170</span>), <span class="num">0xA0</span>),
         		    <span class="num">0x24</span>);
</div>

<h2 id="_mm_shuffle_ps-theory">_mm_shuffle_ps (Theory)</h2>

<p>Let’s begin with the explanation of the _mm_shuffle_ps function:</p>

<div class="ida-code"><span class="type">__m128</span> <span class="fn">_mm_shuffle_ps</span>(<span class="type">__m128</span> <span class="var">a</span>, <span class="type">__m128</span> <span class="var">b</span>, <span style="color: #e74c3c;">const int</span> <span class="var">imm8</span>);
</div>

<p>Let’s break down _mm_shuffle_ps. It takes two __m128 vectors (a and b) and an 8-bit immediate (imm8) that decides how the elements from 
a and b get shuffled into the output.<br />
Let’s denote the result as c. The output vector c is constructed as follows:</p>

<ul>
  <li>c[0] → element from ‘a’ selected by the lowest two bits of imm8</li>
  <li>c[1] → element from ‘a’ selected by bits 2–3 of imm8</li>
  <li>c[2] → element from ‘b’ selected by bits 4–5 of imm8</li>
  <li>c[3] → element from ‘b’ selected by bits 6–7 of imm8</li>
</ul>

<p>In short, the immediate value controls which elements from a and b are placed into each position of the result.</p>

<h2 id="_mm_shuffle_ps-example">_mm_shuffle_ps (Example)</h2>

<p>Now let’s walk through and understand a nested _mm_shuffle_ps instruction. Lets start with:</p>

<div class="ida-code"><span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_10F0E70</span>, *(<span class="type">__m128</span> *)(<span class="var">camStruct</span> + <span class="num">0x170</span>), <span class="num">0xA0</span>)
</div>

<p>xmmword_10F0E70 is a static memory address that holds four 32-bit floats:<br />
(1.0f, 1.0f, 1.0f, 1.0f)<br />
*(__m128 *)(camStruct + 0x170) is the camera position:<br />
(-112913.16f, -613576.88f, 2234.39f, 1.0f)<br />
The immediate value 0xA0 (in binary 10100000) tells us how to shuffle the inputs. <br />
so output ‘c’ is:</p>
<ul>
  <li>c[0] -&gt; a[00] , 1.0f</li>
  <li>c[1] -&gt; a[00] , 1.0f</li>
  <li>c[2] -&gt; b[10] , 2234.39f</li>
  <li>c[3] -&gt; b[10] , 2234.39f</li>
</ul>

<p>In the other shuffle intrinsic is:</p>

<div class="ida-code"><span class="fn">_mm_shuffle_ps</span>(*(<span class="type">__m128</span> *)(<span class="var">camStruct</span> + <span class="num">0x170</span>), '<span class="var">c</span>', <span class="num">0x24</span>)
</div>

<p>0x24 in hex is: 00100100<br />
The final output will be:</p>

<ul>
  <li>CamWorldMat_3[0] -&gt; (camStruct + 0x170)[00] , -112913.16f</li>
  <li>CamWorldMat_3[1] -&gt; (camStruct + 0x170)[01] , -613576.88f</li>
  <li>CamWorldMat_3[2] -&gt; c[10] , 2234.39f</li>
  <li>CamWorldMat_3[3] -&gt; c[00] , 1.0f</li>
</ul>

<p>This just seems to give the same vec4. Effectively being CamWorldMat_3 = *(__m128 *)(camStruct + 0x170)</p>

<blockquote>
  <p>I honestly have no idea why the developers chose to perform these shuffle operations when the final result is already 
available in memory at camStruct + 0x170. Could be due to legacy code, a byproduct of compiler optimizations, or perhaps a more 
general-purpose function that handles multiple cases in production. 
As reverse engineers, we often run into code that appears redundant or overly complex until seen the bigger picture. 
While it’s tempting to assume we fully understand the intention behind every instruction, sometimes the best approach 
is to acknowledge what we don’t know and document it and move forward.</p>
</blockquote>

<h3 id="negating-a-vector-with-simd-theory">Negating a Vector with SIMD (Theory)</h3>

<div class="ida-code"><span class="var">CamWorldMat_1_negated</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">camStruct</span> + <span class="num">0x150</span>)));
</div>

<p>The constant xmmword_1138D50 once again holds the values (NaN, NaN, NaN, 0.0f), and is used here as a bitmask just like before.</p>

<div class="ida-code"><span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="var">result_of_above</span>)
</div>

<ul>
  <li>(__m128)0LL creates a 128-bit SIMD vector containing all zeros: (0.0f, 0.0f, 0.0f, 0.0f)</li>
  <li>This Effectively does:
    <ul>
      <li>(0 - x, 0 - y, 0 - z, 0 - 0) → (-x, -y, -z, 0)</li>
    </ul>
  </li>
</ul>

<p>This SIMD instruction is simply a way to negate a 3D vector while keeping the W component cleared. In the context of a 4x4 camera world matrix 
this is used to possibly convert <em>handedness</em>.</p>

<h3 id="_mm_unpack-theory">_mm_unpack (Theory)</h3>

<div class="ida-code"><span class="var">mergedHigh</span> = <span class="fn">_mm_unpackhi_ps</span>(<span class="var">CamWorldMat_1_negated</span>, <span class="var">CamWorldMat_2</span>);
<span class="var">mergedLow</span> = <span class="fn">_mm_unpacklo_ps</span>(<span class="var">CamWorldMat_1_negated</span>, <span class="var">CamWorldMat_2</span>);
</div>

<p>The _mm_unpacklo_ps and _mm_unpackhi_ps instructions are used to merge parts of two __m128 vectors</p>

<p><strong>_mm_unpacklo_ps</strong><br />
This unpacks (merges) the lower 64 bits (the first two floats) of both vectors. So it combines the x and y 
components of each vector in an alternating pattern.</p>

<div class="ida-code"><span class="var">mergedLow</span> = (<span class="var">CamWorldMat_1_negated.x</span>, <span class="var">CamWorldMat_2.x</span>, <span class="var">CamWorldMat_1_negated.y</span>, <span class="var">CamWorldMat_2.y</span>)
</div>

<p><strong>_mm_unpackhi_ps</strong><br />
Similarly merges the higher 64 bits (the last two floats) of both vectors, so it combines the z and w components in the same alternating fashion.</p>

<div class="ida-code"><span class="var">mergedHigh</span> = (<span class="var">CamWorldMat_1_negated.z</span>, <span class="var">CamWorldMat_2.z</span>, <span class="var">CamWorldMat_1_negated.w</span>, <span class="var">CamWorldMat_2.w</span>)
</div>

<h3 id="transposing-and-shuffling-intermediate-vectors-theory">Transposing and Shuffling Intermediate Vectors (Theory)</h3>

<div class="ida-code"><span class="var">v11</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">mergedHigh</span>, <span class="var">CamWorldMat_0</span>, <span class="num">0x24</span>), (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
<span class="var">v12</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">mergedLow</span>, <span class="var">CamWorldMat_0</span>, <span class="num">0x1E</span>), (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
<span class="var">v13</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">mergedLow</span>, <span class="var">CamWorldMat_0</span>, <span class="num">4</span>), (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
</div>

<p>These SIMD operations perform a fast inverse (We will learn Fast inverse later down the write up) of the camera world matrix by transposing its rotational part and 
rearranging coordinate components.</p>

<ul>
  <li>Shuffles components from mergedLow, mergedHigh, and CamWorldMat_0 using _mm_shuffle_ps</li>
  <li>Then masks the result using NaNNaNNaN0f_Mask to zero out the W component (renamed xmmword_1138D50)</li>
</ul>

<p>Since we’ve already broken down how _mm_shuffle_ps and _mm_and_ps work earlier in this post, we won’t repeat that here.<br />
We will see how it all comes together later down the write up.</p>

<h3 id="manual-matrix-reconstruction-from-simd-operations-example">Manual Matrix Reconstruction from SIMD Operations (Example)</h3>

<p><em>(This section is for readers who want to understand exactly how the View matrix gets constructed at the instruction level. 
You can skip ahead to SIMD Matrix multiplication if you’re just here to learn theory)</em></p>

<p>We’re going to take a snapshot of the memory, walk through the SIMD instructions, and confirm how the final matrix rows are built.</p>

<p><strong>Camera World Matrix</strong><br />
<img src="/ViewProj-Blog/assets/images/part-4.2/cam-world-matrix.png" alt="ESP-Image1" /></p>

<p><strong>IDA Disassembly</strong>
<img src="/ViewProj-Blog/assets/images/part-4.2/ida-view-calc.png" alt="ESP-Image1" /></p>

<p>Let’s decode this step-by-step and rebuild the rows of the matrix ourselves to see exactly what’s going on under the hood.</p>

<p>CamWorldMat_0 = [0.416, -0.893, 0.170 0]<br />
CamWorldMat_1_negated = [-0.906, -0.423, 0, 0]<br />
CamWorldMat_2 = [-0.072, 0.154, 0.985, 0]</p>

<p>mergedHigh = [0, 0.985, 0, 0]
mergedLow = [-0.906, -0.072, -0.423, 0.154]</p>

<p><strong>First instruction</strong></p>

<div class="ida-code"><span class="var">v11</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">mergedHigh</span>, <span class="var">CamWorldMat_0</span>, <span class="num">0x24</span>), (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
</div>

<p>Binary of 0x24 is ‘00100100’</p>

<p>SomeRow0 =</p>
<ul>
  <li>merHi[00] = 0</li>
  <li>merHi[01] = 0.985</li>
  <li>CamWorld0[10] = 0.170</li>
  <li>CamWorld0[00] = 0.416</li>
</ul>

<p>BitMask Applied = [0, 0.985, 0.170, 0]</p>

<p><strong>Second Instruction</strong></p>
<div class="ida-code"><span class="var">v12</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">mergedLow</span>, <span class="var">CamWorldMat_0</span>, <span class="num">0x1E</span>), (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
</div>

<p>Binary of 0x1E is ‘00011110’</p>

<p>SomeRow1 =</p>
<ul>
  <li>merLo[10] = -0.423</li>
  <li>merLo[11] = 0.154</li>
  <li>CamWorld0[01] = -0.893</li>
  <li>CamWorld0[00] = 0.416</li>
</ul>

<p>BitMask Applied = [-0.423, 0.154, -0.893, 0]</p>

<p><strong>Third Instruction</strong></p>
<div class="ida-code"><span class="var">v13</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">mergedLow</span>, <span class="var">CamWorldMat_0</span>, <span class="num">0x04</span>), (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
</div>

<p>Binary of 0x04 is ‘00000100’</p>

<p>SomeRow2 =</p>
<ul>
  <li>merLo[00] = -0.906</li>
  <li>merLo[01] = -0.072</li>
  <li>CamWorld0[00] = 0.416</li>
  <li>CamWorld0[00] = 0.416</li>
</ul>

<p>BitMask Applied = [-0.906, -0.072, 0.416, 0]</p>

<p>Let’s keep these Vec4 values in mind, we’ll come back to them shortly.</p>

<p>Before continuing with the manual calculation of the final matrix, let’s take a quick but important 
detour to understand how matrix multiplication works with SIMD and __m128 vectors.</p>

<h3 id="simd-based-vec4--4x4-matrix-multiplication-theory">SIMD-Based Vec4 × 4x4 Matrix Multiplication (Theory)</h3>

<p><strong>Matrix Multiplication With a Vec4</strong>
<img src="/ViewProj-Blog/assets/images/part-4.2/simd-matrix-math.png" alt="ESP-Image1" /></p>

<p>This instruction:</p>

<div class="ida-code"> <span class="var">v16</span>[<span class="num">1</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow1</span>, <span class="var">someRow1</span>, <span class="num">0</span>), <span class="var">ProjMat_0</span>), 
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow1</span>, <span class="var">someRow1</span>, <span class="num">0x55</span>), <span class="var">ProjMat_1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow1</span>, <span class="var">someRow1</span>, <span class="num">0xAA</span>), <span class="var">ProjMat_2</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow1</span>, <span class="var">someRow1</span>, <span class="num">0xFF</span>), <span class="var">ProjMat_3</span>));
</div>

<p>is basically performing a SIMD dot product between a row from the view matrix (someRow1) and each column of the projection matrix 
(ProjMat_0 … ProjMat_3). Here’s how it works:</p>

<p><strong>Step 1: Shuffle</strong></p>
<ul>
  <li>_mm_shuffle_ps(someRow1, someRow1, imm) selects one component of someRow1 and replicates it across all 4 slots of a new __m128.</li>
  <li>The different imm values pick different elements:
    <ul>
      <li>0x00-&gt; picks element 0 (X)</li>
      <li>0x55-&gt; picks element 1 (Y)</li>
      <li>0xAA-&gt; picks element 2 (Z)</li>
      <li>0xFF-&gt; picks element 3 (W)</li>
    </ul>
  </li>
</ul>

<p>After shuffling, each __m128 looks like [X,X,X,X], [Y,Y,Y,Y], etc.</p>

<p><strong>Step 2: Multiply with Projection Matrix</strong></p>

<ul>
  <li>Each shuffled vector is multiplied component-wise with a column of the projection matrix:</li>
</ul>

<div class="ida-code"><span class="fn">_mm_mul_ps</span>(<span class="var">shuffledRow</span>, <span class="var">ProjMat_n</span>)
</div>

<ul>
  <li>This performs 4 parallel multiplications of the same row component with each element in the projection matrix column.</li>
</ul>

<p><strong>Step 3: Sum the results</strong></p>
<ul>
  <li>The _mm_add_ps calls sum all four products together:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">ProjMat_0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">*</span> <span class="n">ProjMat_1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z</span> <span class="o">*</span> <span class="n">ProjMat_2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">ProjMat_3</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>The result is a single row of the final View-Projection matrix in SIMD form (__m128).</li>
</ul>

<p><strong>Step 4: Store the result</strong></p>

<ul>
  <li>v16[1] now holds the second row of the reconstructed VP matrix.</li>
  <li>This same pattern repeats for the other rows, essentially performing a full matrix multiplication using SIMD instructions.</li>
</ul>

<p>At a higher level, what this instruction is doing is nothing more than standard matrix multiplication. If we take a row from the view matrix, say 
[x y z w], and multiply it with the projection matrix, the operation expands like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">x</span>  <span class="n">y</span>  <span class="n">z</span>  <span class="n">w</span><span class="p">]</span>   <span class="o">*</span>  <span class="p">[</span> <span class="n">projMat00</span>  <span class="n">projMat01</span>  <span class="n">projMat02</span>  <span class="n">projMat03</span> <span class="p">]</span>
                  <span class="p">[</span> <span class="n">projMat10</span>  <span class="n">projMat11</span>  <span class="n">projMat12</span>  <span class="n">projMat13</span> <span class="p">]</span>
                  <span class="p">[</span> <span class="n">projMat20</span>  <span class="n">projMat21</span>  <span class="n">projMat22</span>  <span class="n">projMat23</span> <span class="p">]</span>
                  <span class="p">[</span> <span class="n">projMat30</span>  <span class="n">projMat31</span>  <span class="n">projMat32</span>  <span class="n">projMat33</span> <span class="p">]</span>
</code></pre></div></div>

<p>Which produces:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">projMat00</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">projMat10</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">projMat20</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">projMat30</span><span class="p">,</span>
  <span class="n">x</span><span class="o">*</span><span class="n">projMat01</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">projMat11</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">projMat21</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">projMat31</span><span class="p">,</span>
  <span class="n">x</span><span class="o">*</span><span class="n">projMat02</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">projMat12</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">projMat22</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">projMat32</span><span class="p">,</span>
  <span class="n">x</span><span class="o">*</span><span class="n">projMat03</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">projMat13</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">projMat23</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">projMat33</span> <span class="p">]</span>  
</code></pre></div></div>

<p>The results are then added together, producing a new row in the final View-Projection matrix.<br />
This happens for the first three rows (v16[0], v16[1], and v16[2]).</p>

<p>But the last row, v16[3], is a bit different:</p>

<div class="ida-code"> <span class="var">v16</span>[<span class="num">3</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, <span class="num">0</span>), <span class="var">ProjMat_0</span>), 
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, <span class="num">0x55</span>), <span class="var">ProjMat_1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, <span class="num">0xAA</span>), <span class="var">ProjMat_2</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="var">xmmword_1138D10</span>, <span class="num">0xFF</span>), <span class="var">ProjMat_3</span>));
</div>

<p>Here it uses a constant vector (xmmword_1138D10) which has a value of: (0.0, 0.0, 0.0, 1.0)<br />
Since the first three components are zero, those multiplications with ProjMat_0, ProjMat_1, and ProjMat_2 drop out. The only one left is 
is the last one, where w = 1.0 multiplies the row of the Projection matrix.<br />
This effectively copies the last row of the Projection matrix directly into the View-Projection matrix:</p>

<div class="ida-code"> <span class="var">v16</span>[<span class="num">3</span>] = [ <span class="var">projMat30</span>, <span class="var">projMat31</span>, <span class="var">projMat32</span>, <span class="var">projMat33</span> ]
</div>

<p>The translation from the View matrix is skipped here.</p>

<p><strong>Overengineered Construction:</strong></p>

<p>You might have noticed this is Overengineered.<br />
Here, xmmword_1138D10 is simply (0.0, 0.0, 0.0, 1.0).<br />
When you multiply this constant by the projection matrix rows, only the W=1.0 lane survives, which means you’re 
just selecting the last row of the projection matrix (ProjMat_3).</p>

<p>So this whole instruction chain simplifies to:</p>

<div class="ida-code"> <span class="var">v16</span>[<span class="num">3</span>] = <span class="var">ProjMat_3</span>;
</div>

<p>Just like the camera position shuffle, the final VP row construction is an over-engineered SIMD pattern (probably).</p>

<h2 id="comparing-constructed-matrix-with-camera-world-matrix">Comparing Constructed Matrix with Camera World Matrix:</h2>

<ul>
  <li>SomeRow0 = [0, 0.985, 0.170, 0]</li>
  <li>SomeRow1 = [-0.423, 0.154, -0.893, 0]</li>
  <li>SomeRow2 = [-0.906, -0.072, 0.416, 0]</li>
  <li>xmmword_1138D10 = [0.0, 0.0, 0.0, 1.0]</li>
</ul>

<blockquote>
  <p>Previously v11, v12 and v13 respectively</p>
</blockquote>

<p><strong>Let’s recap how it was constructed:</strong><br />
<img src="/ViewProj-Blog/assets/images/part-4.2/simd-matrix-math.png" alt="ESP-Image1" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SomeRow2</span> <span class="n">x</span> <span class="n">Projection</span> <span class="n">Matrix</span> <span class="mi">4</span><span class="n">x4</span><span class="p">;</span>
<span class="n">v16</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SomeRow1</span> <span class="n">x</span> <span class="n">Projection</span> <span class="n">Matrix</span> <span class="mi">4</span><span class="n">x4</span><span class="p">;</span>
<span class="n">v16</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">SomeRow0</span> <span class="n">x</span> <span class="n">Projection</span> <span class="n">Matrix</span> <span class="mi">4</span><span class="n">x4</span><span class="p">;</span>
<span class="n">v16</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmmword_1138D10</span> <span class="n">x</span> <span class="n">Projection</span> <span class="n">Matrix</span> <span class="mi">4</span><span class="n">x4</span><span class="p">;</span> 
</code></pre></div></div>

<p>So the Multiplication Looks like so:</p>

\[\text{NewMatrix} \times \text{ProjectionMatrix} =
\begin{bmatrix}
-0.906 &amp; -0.072 &amp; 0.416 &amp; 0 \\
-0.423 &amp; 0.154 &amp; -0.893 &amp; 0 \\
0 &amp; 0.985 &amp; 0.170 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1.0
\end{bmatrix}
\times
\begin{bmatrix}
1.264 &amp; 0.000 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 2.247 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 0.000 &amp; 0.000 &amp; 1.000 \\
0.000 &amp; 0.000 &amp; 10.000 &amp; 0.000
\end{bmatrix}\]

<p>Let’s compare the newly constructed matrix with the original Camera World Matrix to understand how it was derived:</p>

\[New Matrix =
\begin{bmatrix}
-0.906 &amp; -0.072 &amp; 0.416 &amp; 0 \\
-0.423 &amp; 0.154 &amp; -0.893 &amp; 0 \\
0 &amp; 0.985 &amp; 0.170 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1.0
\end{bmatrix}\]

\[CamWorldMat =
\begin{bmatrix}
0.416 &amp; -0.893 &amp; 0.170 &amp; 0 \\
0.906 &amp; 0.423 &amp; 0 &amp; 0 \\
-0.072 &amp; 0.154 &amp; 0.985 &amp; 0 \\
-112913.16 &amp; -613576.88 &amp; 2234.39 &amp; 1.0
\end{bmatrix}\]

<p>From this comparison, we can see that the new matrix is essentially a rearranged and partially negated version of the Camera World Matrix’s (we found in memory)</p>

<blockquote>
  <p>Later in Part 4.3 we find the actual Matrix the engine uses for it’s camera transform.</p>
</blockquote>

<p>So the Newly Constructed Matrix is constructed like so from the camera world matrix:</p>

<ul>
  <li>Row[0] from CamWorldMat → becomes Column[2]</li>
  <li>Row[1] from CamWorldMat → becomes –Column[0]</li>
  <li>Row[2] from CamWorldMat → becomes Column[1]</li>
</ul>

<p>This is Basically doing a <em>Fast inverse for orthonormal Matrices</em> with an additional <em>Coordinate Swap</em></p>

<blockquote>
  <p>Keep in mind \(ViewMatrix=(CamWorldMatrix)^{−1}\)</p>
</blockquote>

<h2 id="fast-inverse-for-orthonormal-matrices">Fast inverse for orthonormal Matrices</h2>

<p>If R is a pure rotation matrix meaning:</p>

<ul>
  <li>No scaling,</li>
  <li>No shear,</li>
  <li>It’s orthonormal (columns are perpendicular and unit-length)</li>
</ul>

<p>then \(R^{-1} = R^T\)</p>

<p>Let me explain this theory a bit better:</p>

<p>Suppose a 4x4 matrix with homogenous coordinates:</p>

\[C_{world} =
\begin{bmatrix}
R_{00} &amp; R_{01} &amp; R_{02} &amp; 0 \\
R_{10} &amp; R_{11} &amp; R_{12} &amp; 0 \\
R_{20} &amp; R_{21} &amp; R_{22} &amp; 0 \\
T_x &amp; T_y &amp; T_z &amp; 1.0
\end{bmatrix}\]

<p>Here:</p>
<ul>
  <li>R (upper 3×3) is the orientation of the camera in world space.</li>
  <li>T (bottom row, first 3 values) is the position of the camera in world space.</li>
</ul>

<p>To get \(C_{world}^{-1}\) we can separate the matrix like so:</p>

\[C_{world} =
\begin{bmatrix}
R &amp; 0 \\
T &amp; 1
\end{bmatrix}\]

<p>and we want its inverse.</p>

<p>The block matrix inverse formula for this special form  is:</p>

\[\begin{bmatrix} 
A &amp; 0 \\ 
B &amp; 1 
\end{bmatrix}^{-1}
=
\begin{bmatrix} 
A^{-1} &amp; 0 \\ 
-BA^{-1} &amp; 1 
\end{bmatrix}\]

<p><em>(See <a href="https://en.wikipedia.org/wiki/Invertible_matrix#Blockwise_inversion">Wikipedia: Blockwise inversion</a> for the general derivation)</em></p>

<p>Applying The Formula we get:</p>

<ul>
  <li>A = R</li>
  <li>B = T</li>
</ul>

<p>So:</p>

\[C_{world}^{-1} =
\begin{bmatrix}
R^{-1} &amp; 0 \\
-TR^{-1} &amp; 1
\end{bmatrix}\]

<p>Since R is orthonormal (\(R^{-1} = R^T\)):</p>

\[C_{world}^{-1} =
\begin{bmatrix}
R^T &amp; 0 \\
-TR^T &amp; 1
\end{bmatrix}\]

<blockquote>
  <p>Exponent “T” represents the Transpose and Regular “T” represents the Translation</p>
</blockquote>

<p>Now Expand  \(−TR^T\) into its dot products:</p>

<p>if:</p>

\[R =
\begin{bmatrix}
R_{0x} &amp; R_{0y} &amp; R_{0z} \\
R_{1x} &amp; R_{1y} &amp; R_{1z} \\
R_{2x} &amp; R_{2y} &amp; R_{2z} \\
\end{bmatrix}\]

<p>and \(T = [T_x, T_y, T_z],\)</p>

<p>So:</p>

\[-TR^T=
\begin{bmatrix} 
-T_x &amp; -T_y &amp; -T_z \\
\end{bmatrix}
\times
\begin{bmatrix}
R_{0x} &amp; R_{1x} &amp; R_{2x} \\
R_{0y} &amp; R_{1y} &amp; R_{2y} \\
R_{0z} &amp; R_{1z} &amp; R_{2z} \\
\end{bmatrix}\]

<p>then:</p>

\[-TR^T = [-dot(T,R_0), -dot(T,R_1), -dot(T,R_2)]\]

<p>So the last row becomes:</p>

\[[-dot(T,R_0), -dot(T,R_1), -dot(T,R_2)]\]

<p>And Expanding \(R^T\) is just the Transpose of the Rotation, thus completing the inverse:</p>

\[C_{world}^{-1} =
\begin{bmatrix}
R^T &amp; 0 \\
-TR^T &amp; 1
\end{bmatrix}\]

<p>Here for the last row the engine does another method (which we will reverse in Part 4.3):</p>

<p>They take Negated LastRow of \(C_{world}\) (Translation) and multiply it with View Matrix without Translation and add the calculated 
output into the last row.</p>

<p>This is mathamatically the same as:</p>

\[-TR^T = [-dot(T,R_0), -dot(T,R_1), -dot(T,R_2)]\]

<blockquote>
  <p>No i wont show proof, do it yourself and confirm</p>
</blockquote>

<p>The only difference seen in this Engine is that they also do:</p>
<ul>
  <li>A Coordinate Swap.</li>
  <li>Changes Handedness.</li>
</ul>

<blockquote>
  <p>⚠️ Note:<br />
This fast inverse only works for rigid transforms (no scale/shear).
For a general 4×4 matrix you must use:<br />
\(\begin{align}M^{-1} = \frac{1}{det(M)}  adj(M)\end{align}\)</p>
</blockquote>

<h2 id="continuaton-of-manual-matrix-reconstruction-example">Continuaton of Manual Matrix Reconstruction (Example)</h2>

<p>Now that we know how SIMD-Based Vec4 × 4x4 Matrix Multiplication works let’s continue the Matrix Reconstruction.</p>

<ul>
  <li>SomeRow0 = [0, 0.985, 0.170, 0]</li>
  <li>SomeRow1 = [-0.423, 0.154, -0.893, 0]</li>
  <li>SomeRow2 = [-0.906, -0.072, 0.416, 0]</li>
</ul>

<p>Lets construct v16[0] as an example:</p>

<div class="ida-code"> <span class="var">v16</span>[<span class="num">0</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow2</span>, <span class="var">someRow2</span>, <span class="num">0</span>), <span class="var">ProjMat_0</span>), 
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow2</span>, <span class="var">someRow2</span>, <span class="num">0x55</span>), <span class="var">ProjMat_1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow2</span>, <span class="var">someRow2</span>, <span class="num">0xAA</span>), <span class="var">ProjMat_2</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">someRow2</span>, <span class="var">someRow2</span>, <span class="num">0xFF</span>), <span class="var">ProjMat_3</span>));
</div>

<p><strong>After Shuffling:</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_mm_mul_ps</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.906</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.906</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.906</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.906</span><span class="p">]</span> <span class="p">,</span> <span class="n">ProjMat_0</span><span class="p">),</span>
<span class="n">_mm_mul_ps</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.072</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.072</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.072</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.072</span><span class="p">]</span> <span class="p">,</span> <span class="n">ProjMat_1</span><span class="p">)),</span>
<span class="n">_mm_mul_ps</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.416</span><span class="p">,</span> <span class="mf">0.416</span><span class="p">,</span> <span class="mf">0.416</span><span class="p">,</span> <span class="mf">0.416</span><span class="p">]</span> <span class="p">,</span> <span class="n">ProjMat_2</span><span class="p">)),</span>
<span class="n">_mm_mul_ps</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">ProjMat_3</span><span class="p">));</span>
</code></pre></div></div>

<p>For reference, The Projection Matrix:<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/a1+200-matrix.png" alt="ESP-Image1" /></p>

<p><strong>After Multipling:</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span>
             <span class="n">_mm_add_ps</span><span class="p">(</span>
               <span class="n">_mm_add_ps</span><span class="p">(</span>
		<span class="p">[</span><span class="o">-</span><span class="mf">1.145</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
		 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.161</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
		   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.416</span><span class="p">])</span>
		    	<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<p><strong>After Addition:</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.145</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.161</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.416</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="confirmation-of-vp-matrix">Confirmation Of VP Matrix:</h2>

<p><img src="/ViewProj-Blog/assets/images/part-4.2/VP_matrix.png" alt="ESP-Image1" /></p>

<p>Here we see the 0th row of the VP matrix matches exactly as our manual reconstruction of the row.</p>

<h2 id="passing-the-results-forward">Passing the Results Forward</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="nf">sub_7FBF10</span><span class="p">(</span><span class="n">camStruct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v15</span><span class="p">,</span> <span class="n">v16</span><span class="p">);</span>
</code></pre></div></div>

<p>Now that the function has finished constructing the ViewProjection matrix (without translation), it makes its final call:</p>

<ul>
  <li>&amp;v15 = (camera position)</li>
  <li>v16 = (ViewProjection matrix without translation)</li>
</ul>

<p>The sub_7FBF10 function constructs the View-Projection Matrix with Translation.</p>

<blockquote>
  <p><strong>Why use View-Projection Matrix without Translation?</strong><br />
That’s usually for the skybox.<br />
If the camera’s position (translation) was applied, the sky would “move” as you walk around, By removing translation, 
the skybox always stays centered on you, and only rotation matters</p>
</blockquote>

<p><em>That wraps up the partial View-Projection matrix construction. In the next post, we’ll look at sub_7FBF10, 
the function that builds the full View-Projection Matrix.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">4.3: Completing the View-Projection Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-4.3-completing-view-proj-matrix/" rel="alternate" type="text/html" title="4.3: Completing the View-Projection Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-4.3-completing-view-proj-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-4.3-completing-view-proj-matrix/"><![CDATA[<style>
.ida-code{
  background:#1e1e1e;
  color:#dcdcdc;
  padding:12px;
  border-radius:8px;
  font-family: Consolas, "Liberation Mono", Menlo, monospace;
  font-size:14px;
  line-height:1.4;
  overflow-x:auto;
  white-space: pre; /* preserve spaces and linebreaks */
}

/* token classes you can use inside the div */
.ida-code .kw    { color:#569cd6; } /* keywords */
.ida-code .type  { color:#4ec9b0; } /* types */
.ida-code .fn    { color:#dcdcaa; } /* functions / intrinsics */
.ida-code .num   { color:#b5cea8; } /* numbers / hex */
.ida-code .var   { color:#9cdcfe; } /* variables */
.ida-code .const { color:#ce9178; } /* globals / constants */
.ida-code .comment{ color:#6a9955; font-style:italic; }
</style>

<p>In the previous section, we built the View-Projection matrix without translation. now it’s time to dive into the function that actually puts everything together into the full 
View-Projection matrix.</p>

<div class="ida-code"><span class="kw">char</span> <span class="kw">__fastcall</span> <span class="fn">sub_7FBF10</span>(<span class="type">__int64</span> <span class="var">a1</span>, <span class="type">__m128</span> *<span class="var">a2</span>, <span class="type">__m128</span> *<span class="var">a3</span>)
{
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x550</span>) = *<span class="var">a2</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x430</span>) = *<span class="var">a3</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x440</span>) = <span class="var">a3</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x450</span>) = <span class="var">a3</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x460</span>) = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="fn">sub_938210</span>(<span class="var">a3</span>, <span class="var">a1</span> + <span class="num">0x4B0</span>);
  <span class="var">result</span> = <span class="fn">_mm_movemask_ps</span>(<span class="fn">_mm_cmplt_ps</span>(*(<span class="type">__m128</span> *)<span class="fn">sub_7CD6F0</span>(&amp;<span class="var">v21</span>, <span class="var">a1</span> + <span class="num">0x430</span>), (<span class="type">__m128</span>)<span class="num">0LL</span>)) == <span class="num">15</span>;
  *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>) = <span class="var">result</span>;
  <span class="var">v7</span> = <span class="var">a3</span>[<span class="num">1</span>];
  <span class="var">v8</span> = *<span class="var">a3</span>;
  <span class="var">v9</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">a2</span>));
  <span class="var">v10</span> = <span class="var">a3</span>[<span class="num">2</span>];
  <span class="var">v11</span> = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v14</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v9</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v15</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v16</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v14</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v14</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
            <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">170</span>), <span class="var">v10</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">255</span>), <span class="var">v11</span>));
  <span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0</span>), *<span class="var">a3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">85</span>), <span class="var">v7</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">255</span>), <span class="var">v11</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(<span class="var">v18</span>, <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">255</span>), <span class="var">v11</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">85</span>), <span class="var">v7</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">0</span>), <span class="var">v8</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">255</span>), <span class="var">v11</span>));
  <span class="var">v19</span> = *(<span class="type">unsigned __int64</span> *)(<span class="var">a1</span> + <span class="num">0x6A4</span>);
  <span class="var">v20</span> = <span class="fn">_mm_movelh_ps</span>((<span class="type">__m128</span>)*(<span class="type">unsigned __int64</span> *)(<span class="var">a1</span> + <span class="num">1708</span>), (<span class="type">__m128</span>)<span class="const">xmmword_10F0E00</span>);
  <span class="var">v21</span> = <span class="var">v19</span>;
  <span class="kw">if</span> ( !<span class="const">byte_34ADB00</span> )
  {
    <span class="fn">sub_7F8F40</span>(<span class="var">a1</span>, (<span class="kw">int</span>)&amp;<span class="var">v21</span>, (<span class="kw">int</span>)&amp;<span class="var">v20</span>, <span class="num">6</span>, <span class="var">a1</span> + <span class="num">1264</span>);
    <span class="var">result</span> = *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>);
    *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x771</span>) = <span class="var">result</span>;
  }
  <span class="kw">return</span> <span class="var">result</span>;
}
</div>

<p>Remember the final call to sub_7FBF10 in the previous function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="nf">sub_7FBF10</span><span class="p">(</span><span class="n">camStruct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v15</span><span class="p">,</span> <span class="n">v16</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>So the first Argument a1 is the camStruct</li>
  <li>Second argument a2 is the CameraPostion</li>
  <li>Third argument a3 is the View-Projection Matrix without Translation</li>
</ul>

<p>Lets rename as such and continue.</p>

<h2 id="matrix-loading-into-memory">Matrix Loading into Memory:</h2>

<div class="ida-code">  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x550</span>) = *<span class="var">CamPos</span>;
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x430</span>) = *<span class="var">VP_NoTrans</span>;
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x440</span>) = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x450</span>) = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x460</span>) = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
</div>

<ul>
  <li>Loads Camera Position into CamStruct + 0x550</li>
  <li>Loads VP Matrix (No_translation) into CamStruct + 0x430</li>
</ul>

<p><strong>Matrix Inverse</strong></p>

<div class="ida-code"><span class="fn">sub_938210</span>(<span class="var">a3</span>, <span class="var">a1</span> + <span class="num">0x4B0</span>);
</div>

<p>We wont dive into this but this basically Makes an inverse Matrix of ViewProj_No_t and saves it to a pointer Camstruct + 0x4B0</p>

<p><strong>We will be skipping functions and instructions that dont seem interesting as it is out of scope for this blog</strong></p>

<h2 id="making-sense">Making sense:</h2>

<p>Let’s Try and make sense of this and rename all relevent variables.</p>

<div class="ida-code">  <span class="var">v7</span> = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  <span class="var">v8</span> = *<span class="var">VP_NoTrans</span>;
  <span class="var">v9</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">a2</span>));
  <span class="var">v10</span> = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  <span class="var">v11</span> = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v14</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v9</span>, <span class="num">0xA0</span>), <span class="num">0x24</span>);
  <span class="var">v15</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v16</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v14</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v14</span>, <span class="num">0xA0</span>), <span class="num">0x24</span>);
</div>

<p>Here is a renamed and cleaned up version.</p>

<div class="ida-code">  <span class="var">VP_NoTrans_Row1</span> = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  <span class="var">VP_NoTrans_Row0</span> = *<span class="var">VP_NoTrans</span>;
  <span class="var">CamPos_Negated_w0</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">CamPos</span>));
  <span class="var">VP_NoTrans_Row2</span> = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  <span class="var">VP_NoTrans_Row3</span> = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
  <span class="var">Mask_0010</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">Mask_0100</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">CamPos_Negated_w1</span> = <span class="fn">_mm_shuffle_ps</span>(
		        <span class="var">CamPos_Negated_w0</span>, 
		        <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w0</span>, <span class="num">0xA0</span>), 
	                <span class="num">0x24</span>);
  <span class="var">Mask_1000</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="comment">// -CamPos with w = 1</span>
  <span class="var">CamPos_Negated_w1_dup</span> = <span class="fn">_mm_shuffle_ps</span>(
			    <span class="var">CamPos_Negated_w1</span>, 
			    <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w1</span>, <span class="num">0xA0</span>), 
			    <span class="num">0x24</span>);
</div>

<h3 id="another-redundant-simd-math-function">Another redundant SIMD math function</h3>

<p>You might have noticed another redundant SIMD function here.</p>

<div class="ida-code"><span class="var">CamPos_Negated_w0</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">CamPos</span>));
<span class="var">CamPos_Negated_w1</span> = <span class="fn">_mm_shuffle_ps</span>(
		      <span class="var">CamPos_Negated_w0</span>, 
		      <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w0</span>, <span class="num">0xA0</span>), 
	              <span class="num">0x24</span>);
<span class="var">CamPos_Negated_w1_dup</span> = <span class="fn">_mm_shuffle_ps</span>(
			  <span class="var">CamPos_Negated_w1</span>, 
			  <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w1</span>, <span class="num">0xA0</span>), 
			  <span class="num">0x24</span>);
</div>

<p><strong>What does this code do?</strong></p>

<p>Basically it takes CamPos [x,y,z,w] where w was already ‘1’ and negates it and keeps it ‘1’ at ‘w’.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CamPos</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="o">-</span><span class="n">z</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>There is no reason for such a simple negation to have this many SIMD operations here and are mostly redundant.</p>

<h3 id="negated-camera-position-multiplication-with-viewprojection-matrix">Negated Camera position Multiplication with ViewProjection Matrix</h3>

<div class="ida-code"><span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
        <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
        <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>

<p>I’ve already shown how <em>vec4 × mat4</em> works in SIMD in my previous post, so I won’t re-explain it here. This is the same thing again.<br />
it’s just multiplying the negated camera position (with w=1) by the ViewProjection matrix without translation. The result is effectively 
adding the translation into the VP matrix which did not have translation.</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.3/ida_view_matrix_math.png" alt="ESP-Image1" /></p>

<p>Now lets make sense of the rest of the SIMD matrix math seen here.</p>

<h3 id="even-more-redundant-simd-operations">Even More redundant SIMD operations</h3>

<p>There are useless vec4 × mat4 littered throughout the function, like here:</p>

<div class="ida-code">*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                            <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xFFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>

<p>you might be surprised but this whole SIMD spaghetti can be reduced to just a single assignment:</p>

<div class="ida-code">*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) =  <span class="var">VP_NoTrans_Row2</span>;
</div>

<p><strong>Why?</strong></p>

<p>The Mask_0010 vector value is (0, 0, 1, 0).</p>

<p>The code multiplies this mask by each row of the matrix:</p>

<ul>
  <li>0 * Row0 = Zero</li>
  <li>0 * Row1 = Zero</li>
  <li>1 * Row2 = Row2</li>
  <li>0 * Row3 = Zero</li>
</ul>

<p>Adding these together: Zero + Zero + Row2 + Zero = Row2.</p>

<p>This mask makes sure that only the 2nd row gets preserved and the rest get zeroed out.</p>

<h4 id="biggest-reduction-in-simd-operations">Biggest reduction in SIMD operations:</h4>

<p><strong>Here is the biggest reduction in SIMD operations</strong></p>

<p>From:</p>

<div class="ida-code"> <span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(
	 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(<span class="var">v18</span>, <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0</span>), <span class="var">VP_NoTrans_Row0</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));

</div>

<p>To:</p>

<div class="ida-code">  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="var">VP_NoTrans_Row0</span>
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="var">VP_NoTrans_Row1</span>
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="var">VP_NoTrans_Row2</span>
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>
</div>

<ul>
  <li>Mask_1000 is (1, 0, 0, 0)</li>
  <li>Mask_0100 is (0, 1, 0, 0)</li>
  <li>Mask_0010 is (0, 0, 1, 0)</li>
</ul>

<p>Multiplying a unit vector by a matrix simply extracts the corresponding row. The original code was 
laboriously performing this extraction manually for each axis:</p>

<ul>
  <li>The calculation for 0x240 used Mask_1000 to extract Row0.</li>
  <li>The calculation for 0x250 used Mask_0100 to extract Row1.</li>
  <li>The calculation for 0x260 used Mask_0010 to extract Row2.</li>
</ul>

<p><em>We will Actually manually optimize SIMD assembly instructions to make use of this finding in the next post.</em></p>

<h3 id="continuaton-of-manual-matrix-reconstruction">Continuaton of Manual Matrix Reconstruction</h3>

<p>The last SIMD math operation we need to do before we get the entire ViewProjection Matrix is:</p>

<div class="ida-code"><span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
        <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
        <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>

<p>which is basically:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CamPos_Negated_w1_dup</span><span class="p">[</span><span class="n">Vec4</span><span class="p">]</span> <span class="o">*</span> <span class="n">VP_NoTrans</span><span class="p">[</span><span class="n">Matrix</span><span class="p">]</span>
</code></pre></div></div>

<p>Let’s use our previous snapshot where:</p>

<p>Camera World Matrix:<br />
<img src="/ViewProj-Blog/assets/images/part-4.2/cam-world-matrix.png" alt="ESP-Image1" /></p>

<p>ViewProjection Matrix (Without Translation):<br />
<img src="/ViewProj-Blog/assets/images/part-4.2/VP_matrix.png" alt="ESP-Image1" /></p>

<ul>
  <li>CamPos = [-112913.200, -613576.900, 2234.394, 1.00]</li>
  <li>CamPos_Negated = [112913.200, 613576.900, -2234.394, 1.00]</li>
</ul>

<p>Now let’s multiply this negated camera position with the ViewProjection Matrix (without translation) to confirm if we get the full 
ViewProjection matrix:</p>
<blockquote>
  <p>Floating-point precision of 13 was used during multiplication to keep results accurate.</p>
</blockquote>

<p><img src="/ViewProj-Blog/assets/images/part-4.3/VP_full_result.png" alt="ESP-Image1" />
<img src="/ViewProj-Blog/assets/images/part-4.3/VP_matrix_full.png" alt="ESP-Image1" /></p>

<p><strong>Last Row Matches Perfectly</strong></p>

<h3 id="the-viewprojection-matrix---fully-reversed">The ViewProjection Matrix - Fully Reversed</h3>

<p>Let’s Recap what we have uncovered by reversing the entire construction of the VP matrix down to its SIMD operations.</p>

<p>Our initial problem was straightforward:<br />
Multiplying the View and Projection matrices directly did not produce the correct ViewProjection (VP) matrix used by the engine</p>

<p>After reversing and verifying, down to the SIMD instruction level, we discovered how the game actually constructs its View matrix from the Camera World matrix:</p>

<ul>
  <li>Row[0] → becomes Column[2]</li>
  <li>Row[1] → becomes –Column[0]</li>
  <li>Row[2] → becomes Column[1]</li>
  <li>Row[3] → becomes (0, 0, 0, 1)</li>
</ul>

<p>Once this View matrix is built, the engine multiplies it with the Projection matrix to produce an intermediate matrix, essentially the ViewProjection matrix without the 
translation component applied yet.</p>

<p>Finally, the engine takes this intermediate matrix and multiplies it with the negated camera position, producing the final ViewProjection matrix:</p>

<ul>
  <li>Row[0] → becomes Column[2]</li>
  <li>Row[1] → becomes –Column[0]</li>
  <li>Row[2] → becomes Column[1]</li>
  <li>Row[3] → Computed as -dot(vec, CamPos)</li>
</ul>

<blockquote>
  <p>Note: Multiplying the negated camera position with the ViewProjection matrix (without the translation component) is mathematically equivalent to
–dot(vec, CamPos) as explained in part <a href="../part-4.2-reversing-simd-instrustions/#fast-inverse-for-orthonormal-matrices">4.2: Fast inverse for orthonormal Matrices</a></p>
</blockquote>

<h3 id="final-verification">Final Verification:</h3>

<p>Let’s take the Camera world Matrix:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.2/cam-world-matrix.png" alt="ESP-Image1" /></p>

<p>And the Projection Matrix:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.3/projection_matrix.png" alt="ESP-Image1" /></p>

<p>Trying to construct the intermediate Matrix (ViewProjection matrix without the translation) by following:</p>

<ul>
  <li>Row[0] → becomes Column[2]</li>
  <li>Row[1] → becomes –Column[0]</li>
  <li>Row[2] → becomes Column[1]</li>
  <li>Row[3] → becomes (0, 0, 0, 1)</li>
</ul>

<p>We get:</p>

\[Intermediate Matrix =
\begin{bmatrix}
-0.906 &amp; -0.072 &amp; 0.416 &amp; 0 \\
-0.423 &amp; 0.154 &amp; -0.893 &amp; 0 \\
0 &amp; 0.985 &amp; 0.170 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1.0
\end{bmatrix}\]

<p>Multiply it with the projection Matrix:</p>

\[\text{IntermediateMatrix} \times \text{ProjectionMatrix} =
\begin{bmatrix}
-0.906 &amp; -0.072 &amp; 0.416 &amp; 0 \\
-0.423 &amp; 0.154 &amp; -0.893 &amp; 0 \\
0 &amp; 0.985 &amp; 0.170 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1.0
\end{bmatrix}
\times
\begin{bmatrix}
1.264 &amp; 0.000 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 2.247 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 0.000 &amp; 0.000 &amp; 1.000 \\
0.000 &amp; 0.000 &amp; 10.000 &amp; 0.000
\end{bmatrix}\]

<p>Result:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.3/result_vp_notrans.png" alt="ESP-Image1" /></p>

<p>Comparing aganist in-game memory:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.2/VP_matrix.png" alt="ESP-Image1" /></p>

<p>Great, It matches.</p>

<p>Next is multiplying the negated camera position with this Matrix:</p>

\[\text{negCamPos} \times \text{ProjectionMatrix} =
\begin{bmatrix}
112913.16 &amp; 613576.88 &amp; -2234.39 &amp; 1 
\end{bmatrix}
\times
\begin{bmatrix}
-1.146 &amp; -0.161 &amp; 0.000 &amp; 0.416 \\
-0.534 &amp; 0.346 &amp; 0.000 &amp; -0.893 \\
0.000 &amp; 2.215 &amp; 0.000 &amp; 0.170 \\
0.000 &amp; 0.000 &amp; 10.000 &amp; 0.000
\end{bmatrix}\]

<p>Result:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.3/VP_full_result.png" alt="ESP-Image1" /></p>

<p>Comparing against in-game memory:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.3/VP_matrix_full.png" alt="ESP-Image1" /></p>

<blockquote>
  <p>Higher float presicon was used</p>
</blockquote>

<p>Doing this in one Matrix Multiply we get a View Matrix that is built something like this:</p>

\[\text{ViewMatrix} \times \text{ProjectionMatrix} =
\begin{bmatrix}
-u_x &amp; f_x &amp; r_x &amp; 0 \\
-u_y &amp; f_y &amp; r_y &amp; 0 \\
-u_z &amp; f_z &amp; r_z &amp; 0 \\
dot(u, p) &amp; -dot(f, p) &amp; -dot(r, p) &amp; 1.0
\end{bmatrix}
\times
\begin{bmatrix}
1.264 &amp; 0.000 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 2.247 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 0.000 &amp; 0.000 &amp; 1.000 \\
0.000 &amp; 0.000 &amp; 10.000 &amp; 0.000
\end{bmatrix}\]

<p>Thus confriming that:</p>

\[\text{ViewMatrix} \times \text{ProjectionMatrix} =
\begin{bmatrix}
-0.906 &amp; -0.072 &amp; 0.416 &amp; 0 \\
-0.423 &amp; 0.154 &amp; -0.893 &amp; 0 \\
0 &amp; 0.985 &amp; 0.170 &amp; 0 \\
-361842.34 &amp; 84160.3 &amp; -501332.11 &amp; 1.0
\end{bmatrix}
\times
\begin{bmatrix}
1.264 &amp; 0.000 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 2.247 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 0.000 &amp; 0.000 &amp; 1.000 \\
0.000 &amp; 0.000 &amp; 10.000 &amp; 0.000
\end{bmatrix}\]

<p>Gives us the Full View Projection Matrix:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.3/vp_result_4x4.png" alt="ESP-Image1" /></p>

<h3 id="camera-world-matrix-does-not-match">Camera World Matrix Does Not Match?</h3>

<p>The camera world matrix we found was:</p>

\[C_{world} =
\begin{bmatrix}
r_x &amp; r_y &amp; r_z &amp; 0 \\
u_x &amp; u_y &amp; u_z &amp; 0 \\
f_x &amp; f_y &amp; f_z &amp; 0 \\
p_x &amp; p_y &amp; p_z &amp; 1.0
\end{bmatrix}\]

<p>but it’s inverse is supposed to be:</p>

\[C_{world}^{-1} =
\begin{bmatrix}
r_x &amp; u_x &amp; f_x &amp; 0 \\
r_y &amp; u_y &amp; f_y &amp; 0 \\
r_z &amp; u_z &amp; f_z &amp; 0 \\
-dot(r, P) &amp; -dot(u, P) &amp; -dot(f, P) &amp; 1.0
\end{bmatrix}\]

<p>However, the actual view matrix we recovered from the game looks very different:</p>

\[\text{ViewMatrix} =
\begin{bmatrix}
-u_x &amp; f_x &amp; r_x &amp; 0 \\
-u_y &amp; f_y &amp; r_y &amp; 0 \\
-u_z &amp; f_z &amp; r_z &amp; 0 \\
dot(u, p) &amp; -dot(f, p) &amp; -dot(r, p) &amp; 1.0
\end{bmatrix}\]

<p>Whatever matrix the engine uses to position the camera in world space (the camera’s world matrix), its inverse must be the view matrix.
That’s absolute. So i’m sure the camera world matrix we found in memory was not infact the actual matrix used by the engine for it’s internal camera transform.<br />
Instead, the engine likely uses this layout:</p>

\[C_{world} =
\begin{bmatrix}
-u_x &amp; -u_y &amp; -u_z &amp; 0 \\
f_x &amp; f_y &amp; f_z &amp; 0 \\
r_x &amp; r_y &amp; r_z &amp; 0 \\
p_x &amp; p_y &amp; p_z &amp; 1.0
\end{bmatrix}\]

<p>Applying the fast inverse formula:</p>

\[C_{world}^{-1} =
\begin{bmatrix}
R^T &amp; 0 \\
-TR^T &amp; 1
\end{bmatrix}\]

<p>produces the exact view matrix used by the engine.</p>

<p>Thus pretty much confirming the Camera’s world matrix we found in memory is in a textbook layout and not the actual layout used for the 
camera transform.</p>

<p>In short, the camera world matrix doesn’t have to follow the textbook layout.
As long as the engine is consistent in how it expects and inverts it, the result will always be valid.</p>

<h3 id="completion-of-vp-matrix-construction-from-simd-operations">Completion of VP matrix construction from SIMD operations</h3>

<p>Thus completes the reconstruction of the ViewProjection matrix, starting from theoretical concepts, all the way to manual SIMD-level verification. 
Not only does this resolve the original discrepancy, but it also provides a concrete bridge between mathematical theory, graphics pipelines, and 
reverse engineering practice.</p>

<p><em>Next up: Trimming down redundant SIMD instructions using assembly patching and detour hooking. Don’t expect a real performance gain here, 
it’s more about recognizing wasted ops and experimenting with how far we can push the pipeline by hand.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">4.4: Optimizing Redundant SIMD Instructions</title><link href="http://localhost:4000/ViewProj-Blog/part-4.4-optimizing-redundant-simd-instructions/" rel="alternate" type="text/html" title="4.4: Optimizing Redundant SIMD Instructions" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-4.4-optimizing-redundant-simd-instructions</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-4.4-optimizing-redundant-simd-instructions/"><![CDATA[<style>
.asm64-code {
  background: #1e1e1e;
  color: #c5c8c6;
  padding: 12px;
  border-radius: 8px;
  font-family: "Cascadia Code", Consolas, "Liberation Mono", Menlo, monospace;
  font-size: 14px;
  line-height: 1.45;
  overflow-x: auto;
  white-space: pre;
}

/* Assembly token styles */
.asm64-code .kw     { color: #d78700; font-weight: 600; }   /* opcodes like mov, add */
.asm64-code .reg    { color: #5fafaf; }                     /* registers like rax, rcx */
.asm64-code .mem    { color: #af87d7; }                     /* memory refs like [rbx+8] */
.asm64-code .num    { color: #b5cea8; }                     /* numbers / hex */
.asm64-code .label  { color: #ffaf5f; }                     /* labels or jumps */
.asm64-code .comment{ color: #6a9955; font-style: italic; } /* comments */
.asm64-code .const  { color: #ce9178; }                     /* static strings or constants */
</style>

<style>
.ida-code{
  background:#1e1e1e;
  color:#dcdcdc;
  padding:12px;
  border-radius:8px;
  font-family: Consolas, "Liberation Mono", Menlo, monospace;
  font-size:14px;
  line-height:1.4;
  overflow-x:auto;
  white-space: pre; /* preserve spaces and linebreaks */
}

/* token classes you can use inside the div */
.ida-code .kw    { color:#569cd6; } /* keywords */
.ida-code .type  { color:#4ec9b0; } /* types */
.ida-code .fn    { color:#dcdcaa; } /* functions / intrinsics */
.ida-code .num   { color:#b5cea8; } /* numbers / hex */
.ida-code .var   { color:#9cdcfe; } /* variables */
.ida-code .const { color:#ce9178; } /* globals / constants */
.ida-code .comment{ color:#6a9955; font-style:italic; }
</style>

<p>Now it’s time to optimize all the redundant SIMD operations we have seen till now.</p>
<blockquote>
  <p>Expect no performance gain this is only for a learning experience.</p>
</blockquote>

<p>Just for a refresher we took a bottom up approach on finding functions responsible for finding the Construction Function.</p>

<p><strong>Function traced back from:</strong></p>

<p>sub_9AA040 → sub_sub_7FBF10 → sub_7FD060</p>

<p>Let’s First try to optimize sub_7FD060 which we previously renamed to ProjXViewMul.</p>

<p>The redundant or overly complicated SIMD function was:</p>

<div class="ida-code"> <span class="var">v16</span>[<span class="num">3</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, (<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, <span class="num">0</span>), <span class="var">ProjMat_0</span>), 
		 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, (<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, <span class="num">0x55</span>), <span class="var">ProjMat_1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, (<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, <span class="num">0xAA</span>), <span class="var">ProjMat_2</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, (<span class="type">__m128</span>)<span class="var">Mask_0001f</span>, <span class="num">0xFF</span>), <span class="var">ProjMat_3</span>));
</div>

<p>we can change this to achieve the same functionality by simply doing:</p>

<div class="ida-code"> <span class="var">v16</span>[<span class="num">3</span>] = <span class="var">ProjMat_3</span>
</div>

<p>But we cannot just type it into IDA’s pseudo code, we need to patch it manually in assembly.</p>

<h3 id="finding-assembly-responsible-for-this-function">Finding Assembly responsible for this function:</h3>

<p>To find assembly instructions corresponds to out pseudo-code we will use IDA’s synchronize function.</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.4/synchronize_ida.png" alt="ESP-Image1" /></p>

<p>Highlighting what we are looking for:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.4/synchronize_selection_ida.png" alt="ESP-Image1" /></p>

<p>Now we see the corresponding assembly:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.4/synchronize_ida_asm.png" alt="ESP-Image1" /></p>

<p>here i will just do the quick and easy method of nopping out every instruction we don’t need, see which xmm register holds ProjMat_3 
and simply storing it at the appropriate memory address:</p>

<div class="asm64-code"><span class="kw">movaps</span> <span class="reg">v16</span>[3], <span class="reg">xmm</span>
</div>

<p>Let’s see which xmm register holds ProjMat_3</p>

<div class="ida-code"><span class="var">ProjMat_3</span> = *(<span class="type">__m128</span>*)(<span class="var">camStruct</span> + <span class="num">0x230</span>);
</div>

<p>Highlight this like before and we see it corresponds to:</p>

<div class="asm64-code"><span class="kw">movups</span> <span class="reg">xmm10</span>, <span class="reg">xmmword ptr</span> <span class="mem">[rcx+230h]</span> 
</div>

<p>making sure xmm10 is not changed along the way and we can just store it directly at:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.4/v16_storing.png" alt="ESP-Image1" /></p>

<p>xmm11 is the calculated output of the enitre Vec4 x Mat4x4, chaning this to xmm10 will achive the same function.</p>

<p>we will nop out all other instructions:</p>

<h3 id="nopping-instructions">Nopping Instructions:</h3>

<div class="asm64-code"><span class="kw">movups</span>  <span class="reg">xmm4</span>, <span class="mem">cs:Mask_0001f</span>
<span class="kw">movaps</span>  <span class="reg">xmm11</span>, <span class="reg">xmm4</span>
<span class="kw">shufps</span>  <span class="reg">xmm11</span>, <span class="reg">xmm4</span>, <span class="num">0</span>
<span class="kw">movaps</span>  <span class="reg">xmm0</span>, <span class="reg">xmm4</span>
<span class="kw">mulps</span>   <span class="reg">xmm11</span>, <span class="reg">xmm6</span>
<span class="kw">shufps</span>  <span class="reg">xmm0</span>, <span class="reg">xmm4</span>, <span class="num">55h</span> <span class="comment">; 'U'</span>
<span class="kw">mulps</span>   <span class="reg">xmm0</span>, <span class="reg">xmm7</span>
<span class="kw">movaps</span>  <span class="reg">xmm1</span>, <span class="reg">xmm4</span>
<span class="kw">shufps</span>  <span class="reg">xmm1</span>, <span class="reg">xmm4</span>, <span class="num">0AAh</span>
<span class="kw">addps</span>   <span class="reg">xmm11</span>, <span class="reg">xmm0</span>
<span class="kw">mulps</span>   <span class="reg">xmm1</span>, <span class="reg">xmm9</span>
<span class="kw">shufps</span>  <span class="reg">xmm4</span>, <span class="reg">xmm4</span>, <span class="num">0FFh</span>
<span class="kw">addps</span>   <span class="reg">xmm11</span>, <span class="reg">xmm1</span>
<span class="kw">mulps</span>   <span class="reg">xmm4</span>, <span class="reg">xmm10</span>
<span class="kw">addps</span>   <span class="reg">xmm11</span>, <span class="reg">xmm4</span>
</div>

<p>all these are going to nopped out.</p>

<p>Now we are going to nop all these out and change xmm11 to xmm10 in the final movaps in cheat engine and see if it works as intended.</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.4/assembly_patch_v16.png" alt="ESP-Image1" /></p>

<p><img src="/ViewProj-Blog/assets/images/part-4.4/ce_nops.png" alt="ESP-Image1" /></p>

<h3 id="result">Result?</h3>

<p>Game runs as we suspected without any artifacts in game or in UI:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.4/game_runs.gif" alt="ESP-Image1" /></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Part 4.5: Detour Hooking to Optimize SIMD Operations</title><link href="http://localhost:4000/ViewProj-Blog/part-4.5-detour-hooking-simd-operations/" rel="alternate" type="text/html" title="Part 4.5: Detour Hooking to Optimize SIMD Operations" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-4.5-detour-hooking-simd-operations</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-4.5-detour-hooking-simd-operations/"><![CDATA[<style>
.cpp-code {
  background: #1e1e1e;
  color: #dcdcdc;
  padding: 12px;
  border-radius: 8px;
  font-family: "Cascadia Code", Consolas, "Liberation Mono", Menlo, monospace;
  font-size: 14px;
  line-height: 1.45;
  overflow-x: auto;
  white-space: pre;
}

/* token colors */
.cpp-code .kw      { color: #569cd6; }  /* keywords (if, for, return, etc.) */
.cpp-code .type    { color: #4ec9b0; }  /* built-in / user types */
.cpp-code .fn      { color: #dcdcaa; }  /* functions / intrinsics */
.cpp-code .num     { color: #b5cea8; }  /* numbers */
.cpp-code .var     { color: #9cdcfe; }  /* variables */
.cpp-code .const   { color: #ce9178; }  /* string literals */
.cpp-code .comment { color: #6a9955; font-style: italic; } /* comments */
.cpp-code .preproc { color: #c586c0; }  /* #include, #define */
</style>

<style>
.ida-code{
  background:#1e1e1e;
  color:#dcdcdc;
  padding:12px;
  border-radius:8px;
  font-family: Consolas, "Liberation Mono", Menlo, monospace;
  font-size:14px;
  line-height:1.4;
  overflow-x:auto;
  white-space: pre; /* preserve spaces and linebreaks */
}

/* token classes you can use inside the div */
.ida-code .kw    { color:#569cd6; } /* keywords */
.ida-code .type  { color:#4ec9b0; } /* types */
.ida-code .fn    { color:#dcdcaa; } /* functions / intrinsics */
.ida-code .num   { color:#b5cea8; } /* numbers / hex */
.ida-code .var   { color:#9cdcfe; } /* variables */
.ida-code .const { color:#ce9178; } /* globals / constants */
.ida-code .comment{ color:#6a9955; font-style:italic; }
</style>

<p>Before diving into raw assembly, let’s take a step back. The function below is responsible for adding translation into the VP Matrix</p>

<div class="ida-code"><span class="kw">char</span> <span class="kw">__fastcall</span> <span class="fn">sub_7FBF10</span>(<span class="type">__int64</span> <span class="var">a1</span>, <span class="type">__m128</span> *<span class="var">CamPos</span>, <span class="type">__m128</span> *<span class="var">VP_NoTrans</span>)
{
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x550</span>) = *<span class="var">CamPos</span>;
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x430</span>) = *<span class="var">VP_NoTrans</span>;
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x440</span>) = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x450</span>) = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x460</span>) = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
  <span class="fn">sub_938210</span>(<span class="var">VP_NoTrans</span>, <span class="var">a1</span> + <span class="num">0x4B0</span>);
  <span class="var">result</span> = <span class="fn">_mm_movemask_ps</span>(<span class="fn">_mm_cmplt_ps</span>(*(<span class="type">__m128</span> *)<span class="fn">sub_7CD6F0</span>(&amp;<span class="var">v21</span>, <span class="var">a1</span> + <span class="num">0x430</span>), (<span class="type">__m128</span>)<span class="num">0LL</span>)) == <span class="num">15</span>;
  *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>) = <span class="var">result</span>;
  <span class="var">VP_NoTrans_Row1</span> = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  <span class="var">VP_NoTrans_Row0</span> = *<span class="var">VP_NoTrans</span>;
  <span class="var">CamPos_Negated_w0</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">CamPos</span>));
  <span class="var">VP_NoTrans_Row2</span> = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  <span class="var">VP_NoTrans_Row3</span> = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
  <span class="var">Mask_0010</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">Mask_0100</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">CamPos_Negated_w1</span> = <span class="fn">_mm_shuffle_ps</span>(
		        <span class="var">CamPos_Negated_w0</span>, 
		        <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w0</span>, <span class="num">0xA0</span>), 
	                <span class="num">0x24</span>);
  <span class="var">Mask_1000</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="comment">// -CamPos with w = 1</span>
  <span class="var">CamPos_Negated_w1_dup</span> = <span class="fn">_mm_shuffle_ps</span>(
			    <span class="var">CamPos_Negated_w1</span>, 
			    <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w1</span>, <span class="num">0xA0</span>), 
			    <span class="num">0x24</span>);
  <span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
            <span class="fn">_mm_add_ps</span>(
	      <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	      <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  <span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(
	 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(<span class="var">v18</span>, <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0</span>), <span class="var">VP_NoTrans_Row0</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  <span class="var">v19</span> = *(<span class="type">unsigned __int64</span> *)(<span class="var">a1</span> + <span class="num">0x6A4</span>);
  <span class="var">v20</span> = <span class="fn">_mm_movelh_ps</span>((<span class="type">__m128</span>)*(<span class="type">unsigned __int64</span> *)(<span class="var">a1</span> + <span class="num">1708</span>), (<span class="type">__m128</span>)<span class="const">xmmword_10F0E00</span>);
  <span class="var">v21</span> = <span class="var">v19</span>;
  <span class="kw">if</span> ( !<span class="const">byte_34ADB00</span> )
  {
    <span class="fn">sub_7F8F40</span>(<span class="var">a1</span>, (<span class="kw">int</span>)&amp;<span class="var">v21</span>, (<span class="kw">int</span>)&amp;<span class="var">v20</span>, <span class="num">6</span>, <span class="var">a1</span> + <span class="num">1264</span>);
    <span class="var">result</span> = *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>);
    *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x771</span>) = <span class="var">result</span>;
  }
  <span class="kw">return</span> <span class="var">result</span>;
}	

</div>

<p>In the previous post, I already pointed out how the game tends to over-engineer certain SIMD operations, performing a Vec4 × Matrix4x4 to 
reconstruct data that’s already directly available. Now it’s time to actually optimize those sequences.</p>

<p>Take this section from sub_7FBF10, for example. At first glance, it looks like a massive chain of _mm_shuffle_ps, _mm_mul_ps, and 
_mm_add_ps calls:</p>

<div class="ida-code"><span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(
	 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
         <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>));
 *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                             <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
                               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
 *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
 *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(
                             <span class="fn">_mm_add_ps</span>(<span class="var">v18</span>, <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
 *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="fn">_mm_add_ps</span>(
                             <span class="fn">_mm_add_ps</span>(
                               <span class="fn">_mm_add_ps</span>(
                                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0</span>), <span class="var">VP_NoTrans_Row0</span>)),
                               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>

<p>But once you peel away all the unnecessary work, the end result collapses into something much cleaner:</p>

<div class="ida-code">*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="var">VP_NoTrans_Row0</span>
*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="var">VP_NoTrans_Row1</span>
*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="var">VP_NoTrans_Row2</span>
*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>
</div>

<p>This is just the largest redundancy in the function, not the only one.</p>

<p>For this function we will not be manually nopping SIMD instructions in assembly as that is going to take a lot of effort.<br />
Instead we will use a method called detour hooking.</p>

<h3 id="what-is-detour-hooking"><strong>What is detour Hooking?</strong></h3>

<p>Just as the name suggests, detour hooking is a technique that forces a function to take a different route, you modify the machine code at any point of a function so that, 
when execution reaches it, control detours into your handler instead of following the original straight path. You usually do this by overwriting the first few bytes to a 
jump instruction. When that patched area executes, the CPU follows your detour.</p>

<p>Now in your detour you can implement your own custom code to do whatever you want it to, but keep in mind it is critical to preserve the original execution flow. 
This means you must carefully manage the CPU’s state (registers, flags, and stack) to ensure the program continues to behave correctly after your code runs.<br />
Common pitfalls include creating dead ends, returning incorrectly, corrupting registers, misalignment of stack (ABI convention RSP % 16 == 0 when a call is executed) etc.</p>

<p>Think of it this way:</p>

<p>you put a sign on the road that tells execution: “take this turn first,” but the car should always reach point B if you don’t want your game to crash.</p>

<p>Let me explain what we are going to be doing in a high level conceptually:</p>

<p>We’re looking at this function and it’s flooded with redundant SIMD instructions. Most of them contribute to the final ViewProjection result just in 
a very overengineered way that takes away performance (marginally). But scattered in between, there are still useful SIMD ops we need to keep:</p>

<p>Like:</p>

<div class="ida-code"><span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
            <span class="fn">_mm_add_ps</span>(
	      <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	      <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>

<p>This construction of v17 is important as this is the one that adds translation to the ViewProjection matrix. This function is scattered 
among the overengineered SIMD ops.</p>

<h3 id="heres-the-approach"><strong>Here’s the approach:</strong></h3>

<ul>
  <li>Match assembly to pseudocode: I’ll go through the disassembly and identify which SIMD instructions actually correspond to the math we care 
about. The rest is junk.</li>
  <li>Build a custom hook: In a code cave, I’ll re-implement only the useful SIMD ops in the correct order. This way, 
the essential calculations survive but the redundant ops get skipped.</li>
  <li>Redirect execution flow: At the entry point of the redundant section, I’ll overwrite the first 5 bytes with a jmp to my code cave.
    <ul>
      <li>My custom logic runs (only useful SIMD).</li>
      <li>When done, I jmp back into the function after the redundant block, so execution continues.</li>
    </ul>
  </li>
</ul>

<p>This way, we don’t touch every instruction one by one, we just surgically detour into our cleaner version and rejoin the original code later 
skipping all redundant operations.</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.5/redundant_simd_assembly.png" alt="ESP-Image1" /></p>

<p><em>Text highlighted in green is redundant, Text highlighted in black are required calulations.</em></p>

<p>What we will be doing to circumvent it:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.5/detourhook_codecave.png" alt="ESP-Image1" /></p>

<p>Now, before diving in</p>

<p>I won’t be showing how to find code caves here, that is out of scope for this write-up. Just know that in this case, I’ll be using a code cave that’s 
conveniently located close enough to our target function.</p>

<h3 id="5-byte-jmp-hook-vs-12-byte-jmp-hook"><strong>5 Byte Jmp hook vs 12 Byte Jmp hook</strong></h3>

<p>For the actual detour, I’ll be using the classic 5-byte jmp instruction.</p>
<ul>
  <li>It’s made up of E9 (the jmp opcode) + a 4-byte signed relative offset.</li>
  <li>That offset can reach anywhere within ±2 GB of the jump site.</li>
  <li>This is why having a nearby code cave matters, you need the cave within that 2 GB window.</li>
</ul>

<p>If you can’t rely on code caves (maybe there aren’t any close enough), then you can allocate your own memory with something like 
VirtualAllocEx. But in that case, the E9 relative jump won’t cut it anymore unless you allocate between ±2 GB.</p>

<p>That’s when you switch to a mov+jmp sequence:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">absolute</span> <span class="n">address</span><span class="o">&gt;</span>
<span class="n">jmp</span> <span class="n">rax</span>
</code></pre></div></div>
<blockquote>
  <p>Keep in mind this takes an absolute address where as the 5 byte jmp takes the offset from the instruction address to the location we need to go</p>
</blockquote>

<p>It takes more bytes (usually 12 but depends on the register used), but it can jump anywhere in 64-bit address space. So:</p>

<ul>
  <li>If you’ve got a cave nearby → use the 5-byte jmp.</li>
  <li>If not → allocate memory, use mov rax; jmp rax.</li>
</ul>

<p>Either way, the result is the same</p>

<div class="ida-code">*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="var">VP_NoTrans_Row0</span>
*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="var">VP_NoTrans_Row1</span>
*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="var">VP_NoTrans_Row2</span>
*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>
</div>

<p>We will add this in our code-cave (Keep in mind a1 refers to rbp in this specific case):</p>

<ul>
  <li>VP_NoTrans_Row0 holds its value inside xmm8</li>
  <li>VP_NoTrans_Row1 holds its value inside xmm6</li>
  <li>VP_NoTrans_Row2 holds its value inside xmm9</li>
  <li>v17 holds its value inside xmm11</li>
</ul>

<p>All these were found using our previous method of IDA synchronize or just hover over the variable and IDA will display the register which holds it.</p>

<h3 id="writing-our-hook">Writing our hook:</h3>

<div class="cpp-code"><span class="kw">int</span> <span class="fn">main</span>()<br />{
&nbsp;&nbsp;<span class="comment">// Get the process ID</span>
&nbsp;&nbsp;<span class="type">DWORD</span> <span class="var">procId</span> = <span class="fn">GetProcId</span>(<span class="const">L"GhostOfTsushima.exe"</span>);
&nbsp;&nbsp;<span class="fn">CHECK</span>(<span class="var">procId</span>);

&nbsp;&nbsp;<span class="fn">printf</span>(<span class="const">"ProcID: %d \n"</span>, <span class="var">procId</span>);

&nbsp;&nbsp;<span class="comment">// Get the base Address</span>
&nbsp;&nbsp;<span class="var">baseAddr</span> = <span class="fn">GetModuleBaseAddress</span>(<span class="var">procId</span>, <span class="const">L"GhostOfTsushima.exe"</span>);
&nbsp;&nbsp;<span class="fn">CHECK</span>(<span class="var">baseAddr</span>);

&nbsp;&nbsp;<span class="fn">printf</span>(<span class="const">"BaseAddr: %llx \n"</span>, <span class="var">baseAddr</span>);

&nbsp;&nbsp;<span class="comment">// Open a handle to the process with full access</span>
&nbsp;&nbsp;<span class="var">hProcess</span> = <span class="fn">OpenProcess</span>(<span class="const">PROCESS_ALL_ACCESS</span>, <span class="kw">false</span>, <span class="var">procId</span>);
&nbsp;&nbsp;<span class="fn">CHECK</span>(<span class="var">hProcess</span>);

&nbsp;&nbsp;<span class="comment">// Address of where we will place our jump</span>
&nbsp;&nbsp;<span class="type">uintptr_t</span> <span class="var">patchAddr</span> = <span class="var">baseAddr</span> + <span class="var">patchOff</span>;

&nbsp;&nbsp;<span class="comment">// Address of our code cave</span>
&nbsp;&nbsp;<span class="type">uintptr_t</span> <span class="var">caveAddr</span> = <span class="var">baseAddr</span> + <span class="var">caveOff</span>;

&nbsp;&nbsp;<span class="comment">// The address in the original function where execution should continue</span>
&nbsp;&nbsp;<span class="type">uintptr_t</span> <span class="var">originalFuncContinue</span> = <span class="var">baseAddr</span> + <span class="num">0x7FC122</span>;

&nbsp;&nbsp;<span class="comment">// Calculate relative offset for E9 jmp (rel32)</span>
&nbsp;&nbsp;<span class="type">int64_t</span> <span class="var">rel64</span> = (<span class="type">int64_t</span>)<span class="var">caveAddr</span> - ((<span class="type">int64_t</span>)<span class="var">patchAddr</span> + <span class="num">5</span>);
&nbsp;&nbsp;<span class="type">int32_t</span> <span class="var">rel32</span> = (<span class="type">int32_t</span>)<span class="var">rel64</span>;

&nbsp;&nbsp;<span class="comment">// 5-byte jmp instruction: E9 &lt;rel32&gt;</span>
&nbsp;&nbsp;<span class="type">BYTE</span> <span class="var">jmpToCave</span>[<span class="num">5</span>] = { <span class="num">0xE9</span> };
&nbsp;&nbsp;<span class="fn">memcpy</span>(<span class="var">jmpToCave</span> + <span class="num">1</span>, &amp;<span class="var">rel32</span>, <span class="num">4</span>);

&nbsp;&nbsp;<span class="comment">// Overwrite target function bytes with our jump to code cave</span>
&nbsp;&nbsp;<span class="fn">WriteProcessMemory</span>(<span class="var">hProcess</span>, (<span class="type">BYTE*</span>)<span class="var">baseAddr</span> + <span class="var">patchOff</span>, <span class="var">jmpToCave</span>, <span class="fn">sizeof</span>(<span class="var">jmpToCave</span>), <span class="kw">nullptr</span>);

&nbsp;&nbsp;<span class="type">BYTE</span> <span class="var">shellCode</span>[<span class="num">54</span>] = { 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x59</span>, <span class="num">0xDE</span>, <span class="comment">// mulps xmm11, xmm6</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x58</span>, <span class="num">0xD8</span>, <span class="comment">// addps xmm11, xmm0</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x58</span>, <span class="num">0xD9</span>, <span class="comment">// addps xmm11, xmm1</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x58</span>, <span class="num">0xDB</span>, <span class="comment">// addps xmm11, xmm3</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Store final results</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0x9D</span>, <span class="num">0x70</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x270], xmm11</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0x8D</span>, <span class="num">0x60</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x260], xmm9</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0xB5</span>, <span class="num">0x50</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x250], xmm6</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0x85</span>, <span class="num">0x40</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x240], xmm8</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x0F</span>, <span class="num">0x28</span>, <span class="num">0x0D</span>, <span class="num">0x65</span>, <span class="num">0x28</span>, <span class="num">0x8E</span>, <span class="num">0x00</span> <span class="comment">// movaps xmm1, cs:xmmword_10F0E00</span>
&nbsp;&nbsp;};

&nbsp;&nbsp;<span class="comment">// Storage for our payload</span>
&nbsp;&nbsp;<span class="type">BYTE</span> <span class="var">fullPatch</span>[<span class="num">59</span>];
&nbsp;&nbsp;<span class="type">size_t</span> <span class="var">offset</span> = <span class="num">0</span>;

&nbsp;&nbsp;<span class="comment">// Storing our entire payload</span>
&nbsp;&nbsp;<span class="fn">memcpy</span>(&amp;<span class="var">fullPatch</span>[<span class="var">offset</span>], <span class="var">shellCode</span>, <span class="fn">sizeof</span>(<span class="var">shellCode</span>)); <span class="var">offset</span> += <span class="fn">sizeof</span>(<span class="var">shellCode</span>);

&nbsp;&nbsp;<span class="comment">// Calculate relative offset for jump back (from end of cave code)</span>
&nbsp;&nbsp;<span class="type">int64_t</span> <span class="var">rel64_back</span> = (<span class="type">int64_t</span>)<span class="var">originalFuncContinue</span> - ((<span class="type">int64_t</span>)<span class="var">caveAddr</span> + (<span class="type">int64_t</span>)<span class="var">offset</span> + <span class="num">5</span>);
&nbsp;&nbsp;<span class="type">int32_t</span> <span class="var">rel32_back</span> = (<span class="type">int32_t</span>)<span class="var">rel64_back</span>;

&nbsp;&nbsp;<span class="comment">// Jump back: E9 &lt;rel32&gt;</span>
&nbsp;&nbsp;<span class="type">BYTE</span> <span class="var">jmpBack</span>[<span class="num">5</span>] = { <span class="num">0xE9</span> };
&nbsp;&nbsp;<span class="fn">memcpy</span>(<span class="var">jmpBack</span> + <span class="num">1</span>, &amp;<span class="var">rel32_back</span>, <span class="num">4</span>);

&nbsp;&nbsp;<span class="comment">// Store our jump back to our payload</span>
&nbsp;&nbsp;<span class="fn">memcpy</span>(&amp;<span class="var">fullPatch</span>[<span class="var">offset</span>], <span class="var">jmpBack</span>, <span class="fn">sizeof</span>(<span class="var">jmpBack</span>));

&nbsp;&nbsp;<span class="comment">// Write full payload (our SIMD patch + jump back) into code cave</span>
&nbsp;&nbsp;<span class="fn">WriteProcessMemory</span>(<span class="var">hProcess</span>, (<span class="type">BYTE*</span>)<span class="var">baseAddr</span> + <span class="var">caveOff</span>, <span class="var">fullPatch</span>, <span class="fn">sizeof</span>(<span class="var">fullPatch</span>), <span class="kw">nullptr</span>);

&nbsp;&nbsp;<span class="kw">return</span> <span class="num">0</span>;
}
</div>

<h3 id="code-explanation">Code Explanation:</h3>

<p><strong>Process Setup:</strong></p>

<div class="cpp-code">&nbsp;&nbsp;<span class="type">DWORD</span> <span class="var">procId</span> = <span class="fn">GetProcId</span>(<span class="const">L"GhostOfTsushima.exe"</span>);
&nbsp;&nbsp;<span class="var">baseAddr</span> = <span class="fn">GetModuleBaseAddress</span>(<span class="var">procId</span>, <span class="const">L"GhostOfTsushima.exe"</span>);
&nbsp;&nbsp;<span class="var">hProcess</span> = <span class="fn">OpenProcess</span>(<span class="const">PROCESS_ALL_ACCESS</span>, <span class="kw">false</span>, <span class="var">procId</span>);
</div>

<p>We first locate the target game process and obtain a handle to the process for memory patching.</p>

<p><strong>Detour Address Calculation:</strong></p>

<div class="cpp-code">&nbsp;&nbsp;<span class="type">uintptr_t</span> <span class="var">patchAddr</span> = <span class="var">baseAddr</span> + <span class="var">patchOff</span>;
&nbsp;&nbsp;<span class="type">uintptr_t</span> <span class="var">caveAddr</span> = <span class="var">baseAddr</span> + <span class="var">caveOff</span>;
&nbsp;&nbsp;<span class="type">uintptr_t</span> <span class="var">originalFuncContinue</span> = <span class="var">baseAddr</span> + <span class="num">0x7FC122</span>;
</div>

<p>We will calculate the exact location in the original function where we’ll hijack execution.</p>

<p><strong>Forward Detour Creation:</strong></p>
<div class="cpp-code">&nbsp;&nbsp;<span class="comment">// Calculate relative jump to our code cave &lt;rel32&gt;</span>
&nbsp;&nbsp;<span class="type">int64_t</span> <span class="var">rel64</span> = (<span class="type">int64_t</span>)<span class="var">caveAddr</span> - ((<span class="type">int64_t</span>)<span class="var">patchAddr</span> + <span class="num">5</span>);
&nbsp;&nbsp;<span class="type">int32_t</span> <span class="var">rel32</span> = (<span class="type">int32_t</span>)<span class="var">rel64</span>;

&nbsp;&nbsp;<span class="comment">// 5-byte jmp instruction: E9 &lt;rel32&gt;</span>
&nbsp;&nbsp;<span class="type">BYTE</span> <span class="var">jmpToCave</span>[<span class="num">5</span>] = { <span class="num">0xE9</span> };
&nbsp;&nbsp;<span class="fn">memcpy</span>(<span class="var">jmpToCave</span> + <span class="num">1</span>, &amp;<span class="var">rel32</span>, <span class="num">4</span>);
&nbsp;&nbsp;<span class="fn">WriteProcessMemory</span>(<span class="var">hProcess</span>, (<span class="type">BYTE*</span>)<span class="var">baseAddr</span> + <span class="var">patchOff</span>, <span class="var">jmpToCave</span>, <span class="fn">sizeof</span>(<span class="var">jmpToCave</span>), <span class="kw">nullptr</span>);
</div>

<p>We Replace the first 5 bytes at the target address with JMP <code_cave> (Relative Address).</code_cave></p>

<p><strong>SIMD Optimization Payload:</strong></p>

<div class="cpp-code">&nbsp;&nbsp;<span class="type">BYTE</span> <span class="var">shellCode</span>[<span class="num">54</span>] = { 
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x59</span>, <span class="num">0xDE</span>, <span class="comment">// mulps xmm11, xmm6</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x58</span>, <span class="num">0xD8</span>, <span class="comment">// addps xmm11, xmm0</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x58</span>, <span class="num">0xD9</span>, <span class="comment">// addps xmm11, xmm1</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x58</span>, <span class="num">0xDB</span>, <span class="comment">// addps xmm11, xmm3</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Store final results</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0x9D</span>, <span class="num">0x70</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x270], xmm11</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0x8D</span>, <span class="num">0x60</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x260], xmm9</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0xB5</span>, <span class="num">0x50</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x250], xmm6</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x44</span>, <span class="num">0x0F</span>, <span class="num">0x11</span>, <span class="num">0x85</span>, <span class="num">0x40</span>, <span class="num">0x02</span>, <span class="num">0x00</span>, <span class="num">0x00</span>, <span class="comment">// movups [rbp+0x240], xmm8</span>

&nbsp;&nbsp;&nbsp;&nbsp;<span class="num">0x0F</span>, <span class="num">0x28</span>, <span class="num">0x0D</span>, <span class="num">0x65</span>, <span class="num">0x28</span>, <span class="num">0x8E</span>, <span class="num">0x00</span> <span class="comment">// movaps xmm1, cs:xmmword_10F0E00</span>
&nbsp;&nbsp;};
</div>

<p><strong>Return Jump:</strong></p>

<div class="cpp-code">&nbsp;&nbsp;<span class="comment">// Calculate relative offset for jump back (from end of cave code)</span>
&nbsp;&nbsp;<span class="type">int64_t</span> <span class="var">rel64_back</span> = (<span class="type">int64_t</span>)<span class="var">originalFuncContinue</span> - ((<span class="type">int64_t</span>)<span class="var">caveAddr</span> + (<span class="type">int64_t</span>)<span class="var">offset</span> + <span class="num">5</span>);
&nbsp;&nbsp;<span class="type">int32_t</span> <span class="var">rel32_back</span> = (<span class="type">int32_t</span>)<span class="var">rel64_back</span>;

&nbsp;&nbsp;<span class="comment">// Jump back: E9 &lt;rel32&gt;</span>
&nbsp;&nbsp;<span class="type">BYTE</span> <span class="var">jmpBack</span>[<span class="num">5</span>] = { <span class="num">0xE9</span> };
&nbsp;&nbsp;<span class="fn">memcpy</span>(<span class="var">jmpBack</span> + <span class="num">1</span>, &amp;<span class="var">rel32_back</span>, <span class="num">4</span>);

&nbsp;&nbsp;<span class="comment">// Store our jump back to our payload</span>
&nbsp;&nbsp;<span class="fn">memcpy</span>(&amp;<span class="var">fullPatch</span>[<span class="var">offset</span>], <span class="var">jmpBack</span>, <span class="fn">sizeof</span>(<span class="var">jmpBack</span>));

&nbsp;&nbsp;<span class="comment">// Write full payload (our SIMD patch + jump back) into code cave</span>
&nbsp;&nbsp;<span class="fn">WriteProcessMemory</span>(<span class="var">hProcess</span>, (<span class="type">BYTE*</span>)<span class="var">baseAddr</span> + <span class="var">caveOff</span>, <span class="var">fullPatch</span>, <span class="fn">sizeof</span>(<span class="var">fullPatch</span>), <span class="kw">nullptr</span>);
</div>

<p>After our optimized SIMD code executes, we jump back to the original function. The game continues execution exactly where it would have been after the matrix construction, but with 
the over-engineered SIMD code removed.</p>

<h3 id="executing-our-hook"><strong>Executing our hook</strong></h3>

<p>Cheat Engine’s disassembly confirms that our hook was successfully written:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.5/ce_hook_showcase.png" alt="ESP-Image1" /></p>

<p>And our custom payload is seen in the code cave:</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.5/ce_codecave_showcase.png" alt="ESP-Image1" /></p>

<h3 id="observations-in-game-and-memory">Observations in game and memory:</h3>

<p>With the hook active, the game runs normally, no crashes, no artifacting. This validates our assumption that the stripped-out 
SIMD instructions were truly redundant and removing them only avoided a tiny bit of wasted work:</p>

<p><strong>Matrix values remain identical with or without the hook</strong>
<img src="/ViewProj-Blog/assets/images/part-4.5/matrix_comp.png" alt="ESP-Image1" /></p>

<p><strong>In-Game Observation</strong>
<img src="/ViewProj-Blog/assets/images/part-4.5/game_runs.gif" alt="ESP-Image1" /></p>

<blockquote>
  <p>While not strictly redundant (the instructions still contribute to the final result), this sequence is clearly overengineered. 
The same output could be achieved with far fewer operations, which is why we treat them as ‘redundant’ for the purpose of optimization.</p>
</blockquote>

<p><em>The performance gain here is so minuscule you’d honestly get more FPS by closing a calculator app running in the background. But it teaches a 
bigger lesson: systems don’t always do things the cleanest way, and compilers sure as hell aren’t infallible. Do not blindly trust compilers!</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[]]></summary></entry></feed>