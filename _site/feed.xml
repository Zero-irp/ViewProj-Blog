<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/ViewProj-Blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ViewProj-Blog/" rel="alternate" type="text/html" /><updated>2025-07-20T03:49:53+05:30</updated><id>http://localhost:4000/ViewProj-Blog/feed.xml</id><title type="html">Reversing The ViewProjection Matrix</title><subtitle>Reverse Engineering the ViewProjection Pipeline in Ghost of Tsushima</subtitle><author><name>z1rp</name></author><entry><title type="html">Part 2.2: Projection Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix/" rel="alternate" type="text/html" title="Part 2.2: Projection Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix/"><![CDATA[<h3 id="what-is-the-projection-matrix"><strong>What is the Projection Matrix?</strong></h3>

<p>While the View Matrix transforms world coordinates into the camera’s local space, the Projection Matrix transforms that 3D camera space into a clipped 2D space that’s ready for 
display on a screen.<br />
This is the step where perspective is introduced where far objects look smaller, and near objects look larger.</p>
<blockquote>
  <p>view space -&gt; clip space</p>
</blockquote>

<p>The projection matrix defines how the 3D scene (Game) is projected onto a 2D surface (Your screen).<br />
It Determines:</p>
<ul>
  <li>What part of the world is visible through the camera (field of view).</li>
  <li>How deep the camera can see (near/far clipping planes).</li>
  <li>How the perspective distortion should look (objects farther away appear smaller etc…)</li>
  <li>Defines the 3D view Frustum</li>
</ul>

<p>There are two main types of projection matrices</p>
<ul>
  <li><strong>Perspective Projection</strong></li>
  <li><strong>Orthographic Projection</strong></li>
</ul>

<p>Here we will only be looking at the Perspective Projection Matrix.</p>

<h3 id="what-the-projection-matrix-does"><strong>What the Projection Matrix Does:</strong></h3>

<p>The projection matrix warps the view space into what’s known as Normalized Device Coordinates (NDC).<br />
In NDC:</p>
<ul>
  <li>The x, y, and z coordinates are squeezed into a cube from -1 to 1.</li>
  <li>Everything inside this cube is visible.</li>
  <li>Everything outside is clipped (not rendered).</li>
</ul>

<p>The <em>Projection Matrix</em> represnets how the camera sees. It gives the world its sense of depth and perspective, and its parameters -
FOV, aspect ratio, near and far planes define the visible 3D frustum.</p>

<h3 id="layout-of-the-perspective-projection-matrix">Layout of the Perspective Projection Matrix</h3>

<p>Here is the standard layout of a row-major perspective projection matrix (DirectX):</p>

<table>
  <tbody>
    <tr>
      <td>xScale</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>yScale</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>zfar/(zfar - znear)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>-znear*zfar/(zfar - znear)</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Lets breakdown all the parameters:</p>
<ul>
  <li><strong>zNear:</strong> Near clip plane</li>
  <li><strong>zFar:</strong> Far clip plane</li>
  <li><strong>xScale:</strong> 1 / tan(Fov_X/2)</li>
  <li><strong>yScale:</strong> 1 / tan(Fov_Y/2) or 1 / AspectRatio * tan(Fov_X/2) where Fov_Y = (Aspect Ratio * Fov_X)</li>
</ul>

<p><em>We’ll later see how this matrix fits into the full pipeline and how the 3D position finally lands on your screen.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[What is the Projection Matrix?]]></summary></entry><entry><title type="html">Part 1: Introduction</title><link href="http://localhost:4000/ViewProj-Blog/part-1-intro/" rel="alternate" type="text/html" title="Part 1: Introduction" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-1-intro</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-1-intro/"><![CDATA[<p><strong>Prerequisites</strong></p>
<ul>
  <li>Understanding the assembly language (x86-64)</li>
  <li>Basics in Reverse Engineering</li>
  <li>Intermediary knowledge in C++</li>
  <li>Windows API Familiarity</li>
</ul>

<p><strong>What Are we Trying to achieve?</strong></p>

<p>In this blog series, we’re going to reverse engineer how <em>Ghost of Tsushima</em> constructs its <strong>ViewProjection matrix</strong> — the thing that turns 3D world positions into 2D screen coordinates. This is super important for stuff like ESP overlays (you can’t draw a box around an enemy if you don’t know where they are on screen).</p>

<p>We’ll be reverse engineering the game’s rendering pipeline using tools like IDA Pro, breaking down how the ViewProjection matrix is built step by step including all the weird SIMD instructions it uses. The goal is to figure out where it is, how everything fits together, how its constructed and used in the game.</p>

<p><strong>What is an ESP?</strong></p>

<p>ESP stands for <em>Extra-Sensory Perception</em>. In game hacking, it refers to any feature that shows you information you normally wouldn’t be able to see — stuff the game doesn’t intend to show.
For example, an ESP might let you:</p>
<ul>
  <li>See players through walls</li>
  <li>Know their exact health</li>
  <li>Track what’s in their inventory</li>
  <li>Spot hidden loot, traps etc…</li>
</ul>

<p>This gives a huge unfair advantage over others.</p>

<p><strong>What it should look like:</strong></p>

<h2><img src="/ViewProj-Blog/assets/images/part-1/GotEsp-1.png" alt="ESP-Image1" /></h2>
<p><img src="/ViewProj-Blog/assets/images/part-1/GotEsp-2.png" alt="ESP-Image2" /></p>

<p>Snippets of what we will be working with:</p>

<p><strong>IDA PRO:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/ida-view.png" alt="IDA-screenshot" /></p>

<p><strong>Cheat Engine:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/CheatEngine-view.png" alt="CheatEngine-screenshot" /></p>

<p><strong>Visual Studio:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/VisualStudio-view.png" alt="VisualStudio-screenshot" /></p>

<p><strong>Reclass:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/Reclass-view.png" alt="Reclass-screenshot" /></p>

<p>This blog series is just me sharing what I’ve figured out so far while reverse engineering <em>Ghost of Tsushima</em>. There’s always more to understand, and I’m sure some things I say might not be 100% perfect, so if you spot something I missed, or you have better insights, I’d really love to hear from you.</p>

<p>Feel free to reach out to me:</p>
<ul>
  <li>Discord: z1rp#1337</li>
  <li>Email: <a href="mailto:Zer0_1rp@proton.me">Zer0_1rp@proton.me</a></li>
</ul>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[Prerequisites Understanding the assembly language (x86-64) Basics in Reverse Engineering Intermediary knowledge in C++ Windows API Familiarity]]></summary></entry><entry><title type="html">Part 2.1: View Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix/" rel="alternate" type="text/html" title="Part 2.1: View Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix/"><![CDATA[<h3 id="introduction">Introduction</h3>

<p>In 3D computer graphics, transformation matrices are fundamental tools that allow us to represent and manipulate objects in virtual space. 
Three particularly important matrices work together to take 3D world coordinates and transform them into 2D screen coordinates: the 
View Matrix, Projection Matrix, and their combination, the View Projection Matrix</p>

<h3 id="camera-world-matrix"><strong>Camera World Matrix</strong></h3>

<p>Before jumping into the view matrix we first have to know about the camera world matrix and its relation with the view matrix
(some people refer to it by different names, but I’ll just call it the <em>camera world matrix</em>)</p>

<p>The camera world matrix is basically the camera’s own transform. It describes how the
camera is oriented and positioned in world space</p>

<p>It usually looks like this (in row-major form):</p>

<table>
  <tbody>
    <tr>
      <td>right.x</td>
      <td>right.y</td>
      <td>right.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>up.x</td>
      <td>up.y</td>
      <td>up.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Forward.x</td>
      <td>Forward.y</td>
      <td>Forward.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>pos.x</td>
      <td>pos.y</td>
      <td>pos.z</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>Position Vector:
The position of the camera ‘(x,y,z)’ in world space.</p>

<p>we will discuss the right/up/forward vectors in the View Matrix segment and later how this layout differs from Ghost of Tsushima.</p>

<h3 id="what-is-a-view-matrix"><strong>What is a View-Matrix?</strong></h3>

<p>The <em>view matrix</em> is a 4x4 matrix that transforms coordinates from world space into view (or camera) space. It does <strong>not</strong> tell us where the camera is,
that’s what the camera world matrix is for. Instead, the view matrix takes everything in the world and repositions it relative to the camera, 
as if the camera is sitting at the origin (0, 0, 0) and looking straight down its forward axis.</p>

<blockquote>
  <p>world space -&gt; view space</p>
</blockquote>

<p>So in a sense, it’s not the camera that moves but it’s the world that shifts and rotates around the camera</p>

<blockquote>
  <p>The view matrix is just the inverse of the camera world matrix. That inversion is what lets us see the scene from the camera’s perspective.</p>
</blockquote>

<hr />

<h3 id="layout-of-the-view-matrix"><strong>Layout Of the View Matrix</strong></h3>

<p>Here is a row-major, left-handed layout of how the <em>View Matrix</em> looks like</p>

<table>
  <tbody>
    <tr>
      <td>Right.x</td>
      <td>Right.y</td>
      <td>Right.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Up.x</td>
      <td>Up.y</td>
      <td>Up.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Forward.x</td>
      <td>Forward.y</td>
      <td>Forward.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>-dot(Right, Position)</td>
      <td>-dot(Up, Position)</td>
      <td>-dot(Forward, Position)</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This layout isn’t a hard rule — it can change depending on things like whether the engine uses a right-handed or left handed coordinate system, whether it stores matrices in row-major or column-major order, or even custom layouts used for optimization. What matters is consistency: as long as the engine expects that specific layout, it will work. But no matter how it’s arranged, the matrix still needs the same essential components — Right, Up, Forward, and Translation.</p>
</blockquote>

<p>This 4x4 Matrix layout is common in DirectX Games where it is usually row-major and left-handed.<br />
This <em>View Matrix</em> is made up of 4 fundamental vectors:</p>
<ul>
  <li><strong>Right Vector</strong>:  which direction is right from the camera’s perspective</li>
  <li><strong>Up Vector</strong>: which direction is up from the camera’s perspective</li>
  <li><strong>Forward Vector</strong>: which direction the camera is facing</li>
  <li><strong>Translation Vector</strong>: where the camera is positioned in the world</li>
</ul>

<p>Before diving into the fundamental vectors, let’s take a moment to understand row vs. column major order and left- vs. right-handed coordinate systems:</p>

<ul>
  <li><strong>Row-Major</strong>:
The matrix is constructed row by row.</li>
  <li><strong>Column-Major</strong>:
The Matrix is constructed column by column.</li>
</ul>

<blockquote>
  <p>Eg: The right Vector would have occupied the first row in row-major Matrix but the first column in column-major Matrix.</p>
</blockquote>

<ul>
  <li><strong>Left-Handedness:</strong>
+Z points into the screen.</li>
  <li><strong>Right-Handedness:</strong>
+Z points out of the screen.</li>
</ul>

<blockquote>
  <p>This is why in Right-Handed systems the forward Vector or look-At Vector will be <em>negated</em>.</p>
</blockquote>

<h3 id="breaking-down-the-view-matrix-vectors"><strong>Breaking Down the View Matrix Vectors</strong></h3>

<p>The Right, Up and Forward vectors in your matrix define the orientation of an object or camera in 3D space.</p>

<p><strong>Right Vector (X-axis):</strong><br />
The Right vector is a directional vector that points to the right-hand side of the camera in the camera’s local space.
It Defines the camera’s local X-axis</p>

<p><strong>Up Vector (Y-axis):</strong><br />
This is also a directional Vector but points toward the top side of the camera. It points straight up from the camera’s perspective.
It defines the camera’s local Y-axis</p>

<p><strong>Forward Vector:</strong><br />
This Vector points in the direction the camera is facing. (Where the camera is looking at)
It defines the camera’s local Z-axis</p>
<blockquote>
  <p>Forward Vector = (Camera Position - Camera Look At)</p>
</blockquote>

<p>These variables (eg: Right.x or forward.y etc) can map from <em>-1</em> to <em>1</em> or <em>0</em> to <em>1</em> depending on the graphics Api used (eg: directx/OpenGL).</p>

<p><strong>Translation Vector:</strong><br />
This translation vector basically tells the view matrix how to undo the camera’s position and orientation so that the world moves around the camera and not the other way around.
This is derived from a dot product between the orientation vectors and the camera’s position.
In the view matrix, this position is negated to move the world around the camera.</p>

<h3 id="orthogonality-and-relations"><strong>Orthogonality and Relations</strong></h3>

<p>For a camera to behave properly in 3D space, its orientation vectors (Right, Up, Forward) must be orthogonal (Perpendicular) to each other. <br />
In Vector Algebra we know 2 perpendicular vector’s dot product is always 0.</p>
<blockquote>
  <p>Thus:<br />
dot(Right, Up) = 0<br />
dot(Up, Forward) = 0<br />
dot(Forward, Right) = 0</p>
</blockquote>

<p>In Vector Algebra we also know the right hand rule which is:<br />
The cross product of two vectors “A” and “B” results in a new vector (C = A x B). This resultant vector “C” is always perpendicular (orthogonal) 
to both original vectors “A” and “B”.</p>
<blockquote>
  <p>Thus:<br />
cross(Forward, Right) = Up<br />
cross(Forward, Up) = Right<br />
cross(Up, Right) = Forward<br />
(For Left-Handed systems)</p>
</blockquote>

<p>This returns a new vector perpendicular to the two input vectors. This relationship ensures all three orientation axes form a proper 
coordinate system</p>

<p><em>All of these mathematical relationships, spatial orientations, and foundational concepts might seem unnecessary but they are crucial. We’ll
rely on this knowledge to accurately identify the different matrices in memory, decode how the game constructs them, and understand exactly
how the camera views the world. Without this, reverse engineering the pipeline would just be guesswork.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>