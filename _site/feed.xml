<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/ViewProj-Blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ViewProj-Blog/" rel="alternate" type="text/html" /><updated>2025-07-22T23:22:08+05:30</updated><id>http://localhost:4000/ViewProj-Blog/feed.xml</id><title type="html">Reversing The ViewProjection Matrix</title><subtitle>Reverse Engineering the ViewProjection Pipeline in Ghost of Tsushima</subtitle><author><name>z1rp</name></author><entry><title type="html">Part 4.1: Tracing the Matrix Construction Path</title><link href="http://localhost:4000/ViewProj-Blog/part-4.1-tracing-matrix-construction/" rel="alternate" type="text/html" title="Part 4.1: Tracing the Matrix Construction Path" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-4.1-tracing-matrix-construction</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-4.1-tracing-matrix-construction/"><![CDATA[<h3 id="tracing-functions-writing-to-the-view-projection-matrix">Tracing Functions Writing to The View-Projection Matrix</h3>

<p>Lets start by observing which function writes to the View-Projection Matrix by clicking on the “Find out what writes this address” on the first element
of the View-Projection Matrix.</p>

<p><img src="/ViewProj-Blog/assets/images/part-4.1/find-what-writes-vpmatrix.png" alt="ESP-Image1" /></p>

<p>We have found 2 different functions that seem to write to this address.
<img src="/ViewProj-Blog/assets/images/part-4.1/found-what-writes-vpmatrix.png" alt="ESP-Image1" /></p>

<p>The first instruction seems to reference an address “VCRUNTIME140.memset+134:” and the second one reference’s “GhostOfTsushima.exe+9AA0AF:”.<br />
The second instruction intregiues me more so lets look at that one.<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/9aa082-ins-asm-ce.png" alt="ESP-Image1" /></p>

<p>Here [rdi+0x5C0] is our static memory address of the view projection matrix and is getting written into by “xmm0”.</p>

<blockquote>
  <p>In x64 systems, xmm registers are part of the SSE (Streaming SIMD Extensions) register set. Each xmm register is 
128 bits wide, which makes them ideal for handling vectors, matrices, and other packed floating-point operations. Modern Games use 
SIMD (“Single instruction Multiple Data”) instructions using these registers to optimize performance when doing things like 
matrix math and transformations.</p>
</blockquote>

<p>Lets now see where “xmm0” gets its 4, 32bit float values from. In the instruction just above we see “xmm0” gets its value from<br />
“movups xmm0,[rax+00000240]” which means [rax+00000240] would be where it seems to copy the values from.</p>

<p><strong>lets see this entire function in ida before moving further</strong></p>

<p>lets “select current function” in cheat engine to get the function start address which is “GhostOfTsushima.exe+9AA040”.<br />
Lets put this in ida and see its pseudo-code.
<img src="/ViewProj-Blog/assets/images/part-4.1/ida-view-9aa082.png" alt="ESP-Image1" /></p>

<blockquote>
  <p>Don’t forget to rebase IDA to “0” before searching for the address in the function subview!<br />
Alternatively, you can calculate the offset between the Cheat Engine base and the IDA base manually using a calculator.</p>
</blockquote>

<p>While stepping through the function, I didn’t encounter many SIMD instructions like “mm_mul”, “mm_add_ps”, or “mm_shuffle_ps”.
Instead, it appears that the function is primarily copying matrices from dynamic memory into this static location,  possibly from a 
camera struct or a similar source.</p>

<p>Let’s now see what function writes to the dynamic address that its copying from ([rax+0x240]).
<img src="/ViewProj-Blog/assets/images/part-4.1/matrix-copy-ins-write.png" alt="ESP-Image1" /></p>

<p>We can see one instruction reference “GhostOfTsushima.exe+7FC11B:”. Let’s select the current function and plug it into ida to see its pseudo code.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="kr">__fastcall</span> <span class="nf">sub_7FBF10</span><span class="p">(</span><span class="n">__int64</span> <span class="n">a1</span><span class="p">,</span> <span class="n">__m128</span> <span class="o">*</span><span class="n">a2</span><span class="p">,</span> <span class="n">__m128</span> <span class="o">*</span><span class="n">a3</span><span class="p">)</span>
<span class="p">{</span>

  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x550</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">a2</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x430</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">a3</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x440</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x450</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x460</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">sub_938210</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">a1</span> <span class="o">+</span> <span class="mh">0x4B0</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">_mm_movemask_ps</span><span class="p">(</span><span class="n">_mm_cmplt_ps</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)</span><span class="n">sub_7CD6F0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v21</span><span class="p">,</span> <span class="n">a1</span> <span class="o">+</span> <span class="mh">0x430</span><span class="p">),</span> <span class="p">(</span><span class="n">__m128</span><span class="p">)</span><span class="mi">0LL</span><span class="p">))</span> <span class="o">==</span> <span class="mi">15</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x770</span><span class="p">)</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">v7</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">v8</span> <span class="o">=</span> <span class="o">*</span><span class="n">a3</span><span class="p">;</span>
  <span class="n">v9</span> <span class="o">=</span> <span class="n">_mm_sub_ps</span><span class="p">((</span><span class="n">__m128</span><span class="p">)</span><span class="mi">0LL</span><span class="p">,</span> <span class="n">_mm_and_ps</span><span class="p">((</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_1138D50</span><span class="p">,</span> <span class="o">*</span><span class="n">a2</span><span class="p">));</span>
  <span class="n">v10</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">v11</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">v12</span> <span class="o">=</span> <span class="n">_mm_and_ps</span><span class="p">((</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_1138D00</span><span class="p">,</span> <span class="p">(</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_1138D50</span><span class="p">);</span>
  <span class="n">v13</span> <span class="o">=</span> <span class="n">_mm_and_ps</span><span class="p">((</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_1138CF0</span><span class="p">,</span> <span class="p">(</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_1138D50</span><span class="p">);</span>
  <span class="n">v14</span> <span class="o">=</span> <span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v9</span><span class="p">,</span> <span class="n">_mm_shuffle_ps</span><span class="p">((</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_10F0E70</span><span class="p">,</span> <span class="n">v9</span><span class="p">,</span> <span class="mi">160</span><span class="p">),</span> <span class="mi">36</span><span class="p">);</span>
  <span class="n">v15</span> <span class="o">=</span> <span class="n">_mm_and_ps</span><span class="p">((</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_1138CE0</span><span class="p">,</span> <span class="p">(</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_1138D50</span><span class="p">);</span>
  <span class="n">v16</span> <span class="o">=</span> <span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v14</span><span class="p">,</span> <span class="n">_mm_shuffle_ps</span><span class="p">((</span><span class="n">__m128</span><span class="p">)</span><span class="n">xmmword_10F0E70</span><span class="p">,</span> <span class="n">v14</span><span class="p">,</span> <span class="mi">160</span><span class="p">),</span> <span class="mi">36</span><span class="p">);</span>
  <span class="n">v17</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span>
          <span class="n">_mm_add_ps</span><span class="p">(</span>
            <span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v16</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="mi">85</span><span class="p">),</span> <span class="n">v7</span><span class="p">),</span> <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v16</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">a3</span><span class="p">)),</span>
            <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v16</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span> <span class="n">v10</span><span class="p">)),</span>
          <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v16</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">v11</span><span class="p">));</span>
  <span class="n">v18</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v13</span><span class="p">,</span> <span class="n">v13</span><span class="p">,</span> <span class="mi">85</span><span class="p">),</span> <span class="n">v7</span><span class="p">),</span> <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v13</span><span class="p">,</span> <span class="n">v13</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">a3</span><span class="p">));</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x260</span><span class="p">)</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span>
                              <span class="n">_mm_add_ps</span><span class="p">(</span>
                                <span class="n">_mm_add_ps</span><span class="p">(</span>
                                  <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span> <span class="n">v12</span><span class="p">,</span> <span class="mi">85</span><span class="p">),</span> <span class="n">v7</span><span class="p">),</span>
                                  <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span> <span class="n">v12</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">a3</span><span class="p">)),</span>
                                <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span> <span class="n">v12</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span> <span class="n">v10</span><span class="p">)),</span>
                              <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span> <span class="n">v12</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">v11</span><span class="p">));</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x270</span><span class="p">)</span> <span class="o">=</span> <span class="n">v17</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x250</span><span class="p">)</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span> <span class="p">..............</span>
</code></pre></div></div>

<blockquote>
  <p>This is just a snippet of the start of the function.</p>
</blockquote>

<p>In Windows x64, function parameters are passed using the Microsoft x64 calling convention, where the first four arguments are 
passed via registers in the following order:</p>

<ul>
  <li>RCX → first argument (a1)</li>
  <li>RDX → second argument (a2)</li>
  <li>R8 → third argument (a3)</li>
  <li>R9 → fourth argument (a4)</li>
</ul>

<p>Any additional arguments beyond the fourth are passed on the stack. The return value is typically stored in RAX.<br />
With this in mind, we can infer that a1, a2, and a3 in the function correspond to the values of RCX, RDX, and R8 
respectively at the time of the call.<br />
We’ll set a breakpoint at the start of the function in Cheat Engine to further analyze which will  allow us to inspect the 
contents of these registers when the function is called.<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/ce-7fbf10-breakpoint.png" alt="ESP-Image1" /></p>

<p>For now, the only argument of interest is a1, which corresponds to RCX. In this particular call, RCX = 0x2D72494D200.<br />
I consider it “interesting” because of the following code snippet:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x550</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">a2</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x430</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">a3</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x440</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x450</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="o">*</span><span class="p">(</span><span class="n">__m128</span> <span class="o">*</span><span class="p">)(</span><span class="n">a1</span> <span class="o">+</span> <span class="mh">0x460</span><span class="p">)</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</code></pre></div></div>

<p>looking through the function we notice that it loads a single 4x4 matrix and a Vector4 near the start.<br />
Let’s inspect the values at those offsets in memory.<br />
At [a1 + 0x430], we find what appears to be a ViewProjection matrix without the translation component:<br />
<img src="/ViewProj-Blog/assets/images/part-4.1/reclass-view-proj-no-trans.png" alt="ESP-Image1" />
And at [a1 + 0x550], we find a Vector4 that corresponds to the camera position: <br />
<img src="/ViewProj-Blog/assets/images/part-4.1/reclass-cam-pos.png" alt="ESP-Image1" /></p>

<p>Since this function receives the view-projection matrix (without translation) as input, we can reasonably infer that the actual 
multiplication of the View and Projection matrices occurs earlier in the call stack. That means we’ll need to trace back 
further to locate the point where the View and Projection matrices are composed into this intermediate result.<br />
This function appears to take an intermediate view-projection matrix. One without translation and adds the translational components 
to produce the final view-projection matrix used in rendering.</p>
<blockquote>
  <p>We’ll break down this function in detail later, but for now, our goal is to trace the data flow further upstream to locate where 
this matrix begins its construction.</p>
</blockquote>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[Tracing Functions Writing to The View-Projection Matrix]]></summary></entry><entry><title type="html">Part 1: Introduction</title><link href="http://localhost:4000/ViewProj-Blog/part-1-intro/" rel="alternate" type="text/html" title="Part 1: Introduction" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-1-intro</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-1-intro/"><![CDATA[<h3 id="how-this-rabbit-hole-started"><strong>How This Rabbit Hole Started:</strong></h3>

<p>It all began when I was messing around with Ghost of Tsushima, trying to locate the View-Projection matrix to build a working world-to-screen (W2S) function. I eventually found it and it worked as intended.
But while digging through memory, I came across several other interesting matrices. Two of them stood out: the Camera World Matrix and the Perspective Projection Matrix. I figured I 
could reconstruct the View-Projection matrix myself by multiplying the projection matrix with the inverse of the camera world matrix as most graphics pipelines do.
But the result didn’t match the actual View-Projection matrix.
Curious, I started tracing the functions that write to the View-Projection matrix using IDA Pro, ReClass, and Cheat Engine. That’s when I discovered the engine was building the 
matrix in unusual, non-standard ways or maybe it is standard for AAA engines, and this just happens to be the first one I’m reversing.</p>

<h3 id="prerequisites"><strong>Prerequisites</strong></h3>
<ul>
  <li>Understanding the assembly language (x86-64)</li>
  <li>Basics in Reverse Engineering</li>
  <li>Intermediary knowledge in C++</li>
  <li>Windows API Familiarity</li>
</ul>

<h3 id="what-are-we-trying-to-achieve"><strong>What Are we Trying to achieve?</strong></h3>

<p>In this blog series, we’re going to reverse engineer how <em>Ghost of Tsushima</em> constructs its <strong>ViewProjection matrix</strong> - the thing that turns 3D world positions into 2D screen coordinates. This is super important for stuff like ESP overlays (you can’t draw a box around an enemy if you don’t know where they are on screen).</p>

<p>We’ll be reverse engineering the game’s rendering pipeline using tools like IDA Pro, breaking down how the ViewProjection matrix is built step by step including all the weird SIMD instructions it uses. The goal is to figure out where it is, how everything fits together, how its constructed and used in the game.</p>

<h3 id="what-is-an-esp"><strong>What is an ESP?</strong></h3>

<p>ESP stands for <em>Extra-Sensory Perception</em>. In game hacking, it refers to any feature that shows you information you normally wouldn’t be able to see, stuff the game doesn’t intend to show.
For example, an ESP might let you:</p>
<ul>
  <li>See players through walls</li>
  <li>Know their exact health</li>
  <li>Track what’s in their inventory</li>
  <li>Spot hidden loot, traps etc…</li>
</ul>

<p>This gives a huge unfair advantage over others.</p>

<p><strong>What it should look like:</strong></p>

<h2><img src="/ViewProj-Blog/assets/images/part-1/GotEsp-1.png" alt="ESP-Image1" /></h2>
<p><img src="/ViewProj-Blog/assets/images/part-1/GotEsp-2.png" alt="ESP-Image2" /></p>

<p>Snippets of what we will be working with:</p>

<p><strong>IDA PRO:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/ida-view.png" alt="IDA-screenshot" /></p>

<p><strong>Cheat Engine:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/CheatEngine-view.png" alt="CheatEngine-screenshot" /></p>

<p><strong>Visual Studio:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/VisualStudio-view.png" alt="VisualStudio-screenshot" /></p>

<p><strong>Reclass:</strong>
<img src="/ViewProj-Blog/assets/images/part-1/Reclass-view.png" alt="Reclass-screenshot" /></p>

<p>This blog series is just me sharing what I’ve figured out so far while reverse engineering <em>Ghost of Tsushima</em>. There’s always more to understand, and I’m sure some things I say might not be 100% perfect, so if you spot something I missed, or you have better insights, I’d really love to hear from you.</p>

<p>Feel free to reach out to me:</p>
<ul>
  <li>Discord: z1rp#1337</li>
  <li>Email: <a href="mailto:Zer0_1rp@proton.me">Zer0_1rp@proton.me</a></li>
</ul>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[How This Rabbit Hole Started:]]></summary></entry><entry><title type="html">Part 2.1: View Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix/" rel="alternate" type="text/html" title="Part 2.1: View Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.1-view-matrix/"><![CDATA[<h3 id="introduction">Introduction</h3>

<p>In 3D computer graphics, transformation matrices are fundamental tools that allow us to represent and manipulate objects in virtual space. 
Three particularly important matrices work together to take 3D world coordinates and transform them into 2D screen coordinates: the 
View Matrix, Projection Matrix, and their combination, the View Projection Matrix</p>

<h3 id="camera-world-matrix"><strong>Camera World Matrix</strong></h3>

<p>Before jumping into the view matrix we first have to know about the camera world matrix and its relation with the view matrix
(some people refer to it by different names, but I’ll just call it the <em>camera world matrix</em>)</p>

<p>The camera world matrix is basically the camera’s own transform. It describes how the
camera is oriented and positioned in world space</p>

<p>It usually looks like this (in row-major form):</p>

<table>
  <tbody>
    <tr>
      <td>right.x</td>
      <td>right.y</td>
      <td>right.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>up.x</td>
      <td>up.y</td>
      <td>up.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Forward.x</td>
      <td>Forward.y</td>
      <td>Forward.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>pos.x</td>
      <td>pos.y</td>
      <td>pos.z</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>Position Vector:
The position of the camera ‘(x,y,z)’ in world space.</p>

<p>we will discuss the right/up/forward vectors in the View Matrix segment and later how this layout differs from Ghost of Tsushima.</p>

<h3 id="what-is-a-view-matrix"><strong>What is a View-Matrix?</strong></h3>

<p>The <em>view matrix</em> is a 4x4 matrix that transforms coordinates from world space into view (or camera) space. It does <strong>not</strong> tell us where the camera is,
that’s what the camera world matrix is for. Instead, the view matrix takes everything in the world and repositions it relative to the camera, 
as if the camera is sitting at the origin (0, 0, 0) and looking straight down its forward axis.</p>

<blockquote>
  <p>world space -&gt; view space</p>
</blockquote>

<p>So in a sense, it’s not the camera that moves but it’s the world that shifts and rotates around the camera</p>

<blockquote>
  <p>The view matrix is just the inverse of the camera world matrix. That inversion is what lets us see the scene from the camera’s perspective.</p>
</blockquote>

<hr />

<h3 id="layout-of-the-view-matrix"><strong>Layout Of the View Matrix</strong></h3>

<p>Here is a row-major, left-handed layout of how the <em>View Matrix</em> looks like</p>

<table>
  <tbody>
    <tr>
      <td>Right.x</td>
      <td>Right.y</td>
      <td>Right.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Up.x</td>
      <td>Up.y</td>
      <td>Up.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Forward.x</td>
      <td>Forward.y</td>
      <td>Forward.z</td>
      <td>0</td>
    </tr>
    <tr>
      <td>-dot(Right, Position)</td>
      <td>-dot(Up, Position)</td>
      <td>-dot(Forward, Position)</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This layout isn’t a hard rule, it can change depending on things like whether the engine uses a right-handed or left handed coordinate system, whether it stores matrices in row-major or column-major order, or even custom layouts used for optimization. What matters is consistency: as long as the engine expects that specific layout, it will work. But no matter how it’s arranged, the matrix still needs the same essential components: Right, Up, Forward, and Translation.</p>
</blockquote>

<p>This 4x4 Matrix layout is common in DirectX Games where it is usually row-major and left-handed.<br />
This <em>View Matrix</em> is made up of 4 fundamental vectors:</p>
<ul>
  <li><strong>Right Vector</strong>:  which direction is right from the camera’s perspective</li>
  <li><strong>Up Vector</strong>: which direction is up from the camera’s perspective</li>
  <li><strong>Forward Vector</strong>: which direction the camera is facing</li>
  <li><strong>Translation Vector</strong>: where the camera is positioned in the world</li>
</ul>

<p>Before diving into the fundamental vectors, let’s take a moment to understand row vs. column major order and left- vs. right-handed coordinate systems:</p>

<ul>
  <li><strong>Row-Major</strong>:
The matrix is constructed row by row.</li>
  <li><strong>Column-Major</strong>:
The Matrix is constructed column by column.</li>
</ul>

<blockquote>
  <p>Eg: The right Vector would have occupied the first row in row-major Matrix but the first column in column-major Matrix.</p>
</blockquote>

<ul>
  <li><strong>Left-Handedness:</strong>
+Z points into the screen.</li>
  <li><strong>Right-Handedness:</strong>
+Z points out of the screen.</li>
</ul>

<blockquote>
  <p>This is why in Right-Handed systems the forward Vector will be <em>negated</em>.</p>
</blockquote>

<h3 id="breaking-down-the-view-matrix-vectors"><strong>Breaking Down the View Matrix Vectors</strong></h3>

<p>The Right, Up and Forward vectors in your matrix define the orientation of an object or camera in 3D space.</p>

<p><strong>Right Vector (X-axis):</strong><br />
The Right vector is a directional vector that points to the right-hand side of the camera in the camera’s local space.
It Defines the camera’s local X-axis</p>

<p><strong>Up Vector (Y-axis):</strong><br />
This is also a directional Vector but points toward the top side of the camera. It points straight up from the camera’s perspective.
It defines the camera’s local Y-axis</p>

<p><strong>Forward Vector:</strong><br />
This Vector points in the direction the camera is facing. (Where the camera is looking at)
It defines the camera’s local Z-axis</p>
<blockquote>
  <p>Forward Vector = (Camera Position - Camera Look At)</p>
</blockquote>

<p>These variables (eg: Right.x or forward.y etc) can map from <em>-1</em> to <em>1</em> or <em>0</em> to <em>1</em> depending on the graphics Api used (eg: directx/OpenGL).</p>

<p><strong>Translation Vector:</strong><br />
This translation vector basically tells the view matrix how to undo the camera’s position and orientation so that the world moves around the camera and not the other way around.
This is derived from a dot product between the orientation vectors and the camera’s position.
In the view matrix, this position is negated to move the world around the camera.</p>

<h3 id="orthogonality-and-relations--optionalgood-to-know"><strong>Orthogonality and Relations:- (Optional/Good to know)</strong></h3>

<p>For a camera to behave properly in 3D space, its orientation vectors (Right, Up, Forward) must be orthogonal (Perpendicular) to each other. <br />
In Vector Algebra we know 2 perpendicular vector’s dot product is always 0.</p>
<blockquote>
  <p>Thus:<br />
dot(Right, Up) = 0<br />
dot(Up, Forward) = 0<br />
dot(Forward, Right) = 0</p>
</blockquote>

<p>In Vector Algebra we also know the right hand rule which is:<br />
The cross product of two vectors “A” and “B” results in a new vector (C = A x B). This resultant vector “C” is always perpendicular (orthogonal) 
to both original vectors “A” and “B”.</p>
<blockquote>
  <p>Thus:<br />
cross(Forward, Right) = Up<br />
cross(Forward, Up) = Right<br />
cross(Up, Right) = Forward<br />
(For Left-Handed systems)</p>
</blockquote>

<p>This returns a new vector perpendicular to the two input vectors. This relationship ensures all three orientation axes form a proper 
coordinate system</p>

<h3 id="model-matrix--optionalgood-to-know"><strong>Model Matrix:- (Optional/Good to know)</strong></h3>

<p>Before we move forward, it’s worth mentioning the Model Matrix<br />
The Model Matrix is defined by a set of vertices. The X,Y,Z coordinates of these vertices are defined relative to the object’s center,
This Matrix is responsible for transforming a 3D model from its local space into world space handling the model’s position, rotation and scale.</p>

<blockquote>
  <p>Model space -&gt; World space</p>
</blockquote>

<p>For the purpose of world-to-screen projection (basic ESP overlay), we don’t actually need the model matrix.<br />
<strong>Why?</strong><br />
The esp we are building only needs to know where something is in world space and the game has already computed and placed the model in world space.
Since the model matrix just moves the object from local space to world spcae, and we already have the world position, it becomes redundant in this
context.<br />
We don’t use this, but it’s worth knowing because the Camera World Matrix we discussed earlier is just a special case of a Model Matrix: it represents the 
camera’s position and orientation in world space, just like a model matrix does for any object.<br />
<em>So it has the same layout and structure as the Camera world matrix, the only difference is in what it represents</em></p>

<p><strong>If you want to learn more about mode, view and projection matrices you can check this Opengl tutorial out:</strong><br />
<a href="https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-model-view-and-projection-matrices">OpenGL tutorial</a></p>

<p><em>All of these mathematical relationships, spatial orientations, and foundational concepts might seem unnecessary but they are crucial. We’ll
rely on this knowledge to accurately identify the different matrices in memory, decode how the game constructs them, and understand exactly
how the camera views the world. Without this, reverse engineering the pipeline would just be guesswork.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Part 2.2: Projection Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix/" rel="alternate" type="text/html" title="Part 2.2: Projection Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.2-projection-matrix/"><![CDATA[<h3 id="what-is-the-projection-matrix"><strong>What is the Projection Matrix?</strong></h3>

<p>While the View Matrix transforms world coordinates into the camera’s local space, the Projection Matrix transforms that 3D camera space into a clipped 2D space that’s ready for 
display on a screen.<br />
This is the step where perspective is introduced where far objects look smaller, and near objects look larger.</p>
<blockquote>
  <p>view space -&gt; clip space</p>
</blockquote>

<p>The projection matrix defines how the 3D scene (Game) is projected onto a 2D surface (Your screen).<br />
It Determines:</p>
<ul>
  <li>What part of the world is visible through the camera (field of view).</li>
  <li>How deep the camera can see (near/far clipping planes).</li>
  <li>How the perspective distortion should look (objects farther away appear smaller etc…)</li>
  <li>Defines the 3D view Frustum</li>
</ul>

<p>There are two main types of projection matrices</p>
<ul>
  <li><strong>Perspective Projection</strong></li>
  <li><strong>Orthographic Projection</strong></li>
</ul>

<p>Here we will only be looking at the Perspective Projection Matrix.</p>

<h3 id="what-the-projection-matrix-does"><strong>What the Projection Matrix Does:</strong></h3>

<p>The projection matrix warps the view space into what’s known as Normalized Device Coordinates (NDC).<br />
In NDC:</p>
<ul>
  <li>The x, y, and z coordinates are squeezed into a cube from -1 to 1.</li>
  <li>Everything inside this cube is visible.</li>
  <li>Everything outside is clipped (not rendered).</li>
</ul>

<p>The <em>Projection Matrix</em> represnets how the camera sees. It gives the world its sense of depth and perspective, and its parameters:
FOV, aspect ratio, near and far planes define the visible 3D frustum.</p>

<h3 id="layout-of-the-perspective-projection-matrix">Layout of the Perspective Projection Matrix</h3>

<p>Here is the standard layout of a row-major perspective projection matrix (DirectX):</p>

<table>
  <tbody>
    <tr>
      <td>xScale</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>yScale</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>zfar/(zfar - znear)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>-znear*zfar/(zfar - znear)</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Lets breakdown all the parameters:</p>
<ul>
  <li><strong>zNear:</strong> Near clip plane</li>
  <li><strong>zFar:</strong> Far clip plane</li>
  <li><strong>xScale:</strong> 1 / tan(Fov_X/2)</li>
  <li><strong>yScale:</strong> 1 / tan(Fov_Y/2) or 1 / AspectRatio * tan(Fov_X/2) where Fov_Y = (Aspect Ratio * Fov_X)</li>
</ul>

<p><em>We’ll later see how this matrix fits into the full pipeline and how the 3D position finally lands on your screen.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[What is the Projection Matrix?]]></summary></entry><entry><title type="html">Part 2.3: View Projection Matrix</title><link href="http://localhost:4000/ViewProj-Blog/part-2.3-View-Projection-matrix/" rel="alternate" type="text/html" title="Part 2.3: View Projection Matrix" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-2.3-View-Projection-matrix</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-2.3-View-Projection-matrix/"><![CDATA[<h3 id="what-is-the-view-projection-matrix"><strong>What is the View-Projection Matrix?</strong></h3>

<p>The View-Projection Matrix (or simply the <em>VP Matrix</em>) is simply the result of multiplying the View Matrix and the Projection Matrix together:</p>
<blockquote>
  <p>ViewProjection = Projection * View<br />
Note: Matrix multiplication is not commutative:- A * B ≠ B * A<br />
The multiplication order depends on the graphics system, influenced by its row/column major layout and handedness.</p>
</blockquote>

<p>This combined matrix allows you to transform a world-space position directly into clip space in one step. Instead of first 
applying the view matrix, then the projection matrix separately, both transformations are handled at once:</p>

<blockquote>
  <p>clipSpacePos = ViewProjection * worldSpacePos</p>
</blockquote>

<p>This is both mathematically valid and computationally efficient, which is why many engines precompute and cache the View-Projection matrix.<br />
In many game engines the memory this Matrix is stored in is usually in a static memory address due to high reuse for computation thus it makes
more sense to cache it in known spots.</p>

<p>Even though it’s just a product of two other matrices, the View-Projection matrix plays a central role in rendering.
It represents the full transformation from world-space to clip-space and is often the matrix most directly used when deciding what shows up on screen.</p>

<p><em>This is all we’ll cover about the View-Projection matrix for now. The goal isn’t to dive deep into 3D rendering, but to build a clear, 
working understanding of how it functions at a basic level.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[What is the View-Projection Matrix?]]></summary></entry><entry><title type="html">Part 3: Finding &amp;amp; Reversing Matrices</title><link href="http://localhost:4000/ViewProj-Blog/part-3-finding-and-reversing-matrices/" rel="alternate" type="text/html" title="Part 3: Finding &amp;amp; Reversing Matrices" /><published>2025-07-17T00:00:00+05:30</published><updated>2025-07-17T00:00:00+05:30</updated><id>http://localhost:4000/ViewProj-Blog/part-3-finding-and-reversing-matrices</id><content type="html" xml:base="http://localhost:4000/ViewProj-Blog/part-3-finding-and-reversing-matrices/"><![CDATA[<h3 id="how-we-search-for-matrices-in-memory"><strong>How We Search for Matrices in Memory</strong></h3>

<p>A common appraoch is to switch Cheat Engine’s value type in <em>float</em> and then:</p>

<ol>
  <li>Look Directly up and scan for the value <em>1.0f</em>.</li>
  <li>Look Directly Down and scan for the value <em>-1.0f</em>.</li>
  <li>Rescan to narrow the matrices down to matrices that are actively changing with camera orientation.</li>
</ol>

<p>Once you narrow it down, you can inspect nearby memory regions and layout patterns (like a 4x4 float matrix) to identify which matrix it is</p>

<p>This technique works because these matrices are often stored in memory in a row-major or column-major 4x4 float array, and the directional 
vectors (Right, Up, Forward) reflect real-time camera movement</p>

<blockquote>
  <p>Basically Something in the matrix must encode the camera’s up/down rotation</p>
</blockquote>

<h3 id="searching-for-matrices-in-ghost-of-tsushima"><strong>Searching for Matrices in Ghost of Tsushima</strong></h3>

<p>Lets start searching for interesting matrices in memory in ghost of tsushima!</p>

<p><strong>Looking up in game</strong>
<img src="/ViewProj-Blog/assets/images/part-3/look-up-got.png" alt="ESP-Image1" /></p>

<p><strong>Seraching for 1.0f in cheat engine</strong>
<img src="/ViewProj-Blog/assets/images/part-3/ce-first-scan.png" alt="ESP-Image1" /></p>

<p><strong>Now looking Down</strong>
<img src="/ViewProj-Blog/assets/images/part-3/look-down-got.png" alt="ESP-Image1" /></p>

<p><strong>Searching for -1.0f in cheat engine</strong>
<img src="/ViewProj-Blog/assets/images/part-3/ce-second-scan.png" alt="ESP-Image1" /></p>

<p>Now you’re going to get a lot of results. Keep refining your search (e.g., by changing camera angles and scanning again) until the 
number of results stabilizes and stops changing, that’s usually a good sign you’ve isolated the relevant addresses.</p>

<p>Now When reverse engineering a game, you’ll often find that the View, Projection, and View-Projection matrices live at fixed or static memory addresses.<br />
<strong>Why?</strong><br />
Mainly becuase these matrices are core componetns of the game’s rendering pipeline and are global to the camera or render context.</p>

<p>Now we can add all static memory address’s and browse its memory layout’s to see if we find some interesting matrices.</p>

<p><strong>Like Here:</strong>
<img src="/ViewProj-Blog/assets/images/part-3/cam-world-matrix-and-view-matrix.png" alt="ESP-Image1" /></p>

<p>Here the first 4x4 matrix look like the <em>Camera World Matrix</em> and the second 4x4 matrix looks like the <em>View Matrix</em>.</p>

<h3 id="confirmation-of-the-view-and-camera-world-matrices"><strong>Confirmation of the View and Camera World Matrices:</strong></h3>

<p>In <a href="/ViewProj-Blog/part-2.1-view-matrix/">Part 2.1: View Matrix</a> we talked about the orthogonailty and relations of the fundamental Vectors.<br />
Let’s open these matrices in reclass and use these relations to confirm it!</p>

<p>Lets form an Hypothesis that this is the layout of the 4x4 Matrix:
<img src="/ViewProj-Blog/assets/images/part-3/reclass-view-cam-hypothesis.png" alt="ESP-Image1" /></p>

<p>Using its relations we can see:</p>
<ul>
  <li>Dot((-0.104, -0.06, 0.993), (0.5, -0.866, 0.00)) = <em>-3.9999999999998E-5</em> which is basically just <em>0</em> and is just floating-point precision error.</li>
  <li>Cross((-0.104, -0.06, 0.993), (0.5, -0.866, 0.00)) = <em>(0.860, 0.496, 0.121)</em> which basically gave us the second row (starting row’s from 0)</li>
</ul>

<blockquote>
  <p>This is useful because, in reverse engineering, you may not always find a clean and complete 4×4 matrix. Sometimes you only find a few 
direction vectors (like Right and Up) scattered across memory or passed into functions. But thanks to vector math, you can reconstruct the missing third 
vector using cross products, or verify their relationship using dot products (which should be zero for perpendicular vectors). These help validate our findings
(maybe layout is unconventional or partially obfuscated)</p>
</blockquote>

<p>In very rare circumstances, even though it might look like a matrix in might be a random cluster of floats that dont inherently mean anything,
Once we see that the values are orthogonal, have unit lengths, and contain a clear translation component (usually the larger values &gt; 1.0f), 
we can reasonably assume we’re dealing with a real transformation matrix.</p>

<blockquote>
  <p>To be extra sure, you can move the camera left, right, up, and down, and observe how the matrix reacts and see how these vectors react and accuratly 
verify them.</p>
</blockquote>

<p><strong>Lets now inverse it to get the view matrix:</strong>
<img src="/ViewProj-Blog/assets/images/part-3/cam-world-inverse.png" alt="ESP-Image1" /></p>

<p>We can see it exactly matches the second 4x4 matrix we see in memory (Camera World Matrix (Inverse) = View Matrix).</p>

<blockquote>
  <p>We can also take dot(Right, Pos) and compare it against the translation component of the second matrix as another way to confirm this relationship.</p>
</blockquote>

<p>Thus pretty much confirming the first matrix to be <em>Camera World Matrix</em> and the second matrix to be the <em>View Matrix</em>.</p>

<h3 id="looking-at-other-matrices"><strong>Looking at other matrices</strong></h3>

<p>Here we see some other matrices:
<img src="/ViewProj-Blog/assets/images/part-3/reclass-view-projection-matrix.png" alt="ESP-Image1" /></p>

<p>The first Matrix looks like a projection matrix and the second one looks like a multiplication of the projection matrix with the view 
matrix (VP Matrix), the third one looks like the View-projection matrix without large translational values.</p>

<p><strong>Why?</strong><br />
Because they fit the general layout’s expected of these matrices.<br />
To be sure lets plug in the view projection matrix into a world to screen function to see if we can confirm this.</p>

<p>To verify i will manually input the entity coordinates into my world to screen program.<br />
Here is the entity whose position we’ll convert:<br />
<img src="/ViewProj-Blog/assets/images/part-3/view-proj-test-in-game.png" alt="ESP-Image1" /></p>

<p>Since this image shows that the entity is at the top-left corner of our screen at a resolution of 1920x1080 we can expect the screen coordinates to
be close to (0, 0) since the Top-left corner is the origin of the screen (0, 0), not bottom left as you might expect (unlike OpenGl).<br />
<img src="/ViewProj-Blog/assets/images/part-3/view-proj-screen-pos-results.png" alt="ESP-Image1" /></p>

<p>Here we can see the output screen coordinates matches closely to what we expected.</p>

<blockquote>
  <p>We’ll cover how to get the entity’s 3D coordinates and how World-to-Screen works in detail later, for now, this confirms the matrix is correct.</p>
</blockquote>

<h2 id="trying-to-rebuild-the-view-projection-matrix"><strong>Trying to Rebuild the View-Projection Matrix</strong></h2>

<p>Now that we have confrimed that this is infact the view projection matrix lets try to reconstruct it manually</p>

<ol>
  <li>Take the suspected Projection Matrix</li>
  <li>Multiply it by the inverse of the Camera World Matrix</li>
</ol>

<p><img src="/ViewProj-Blog/assets/images/part-3/discrepency-vp-with-vp-multiply.png" alt="ESP-Image1" /><br />
Here for some reason it doesn’t quite match’s up although quite similar.</p>

<p><em>Next Step: Time to start tracing back the functions that write to the final View-Projection Matrix in memory.</em></p>]]></content><author><name>z1rp</name></author><summary type="html"><![CDATA[How We Search for Matrices in Memory]]></summary></entry></feed>