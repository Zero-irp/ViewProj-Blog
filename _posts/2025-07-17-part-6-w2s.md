---
layout: post
title: "Part 6: World To Screen Explanation And Code"
date: 2025-07-17 00:00:00 +0530
permalink: /part-6-w2s/
---

<style>
.cpp-code {
  background: #1e1e1e;
  color: #dcdcdc;
  font-family: 'Fira Code', 'Consolas', monospace;
  font-size: 0.95rem;
  padding: 1rem 1.25rem;
  border-radius: 10px;
  line-height: 1.5;
  overflow-x: auto;
  white-space: pre;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.cpp-code .keyword { color: #569cd6; }
.cpp-code .type { color: #4ec9b0; }
.cpp-code .comment { color: #6a9955; font-style: italic; }
.cpp-code .number { color: #b5cea8; }
.cpp-code .function { color: #dcdcaa; }
.cpp-code .string { color: #ce9178; }
.cpp-code .var { color: #9cdcfe; }
</style>

### What "World to Screen" Means

The name really says it all: world → screen. A World to Screen (W2S) function takes a 3D position in the game’s world space represented as a 
Vector3 (x, y, z) and transforms it into a 2D coordinate on your screen space, an (X, Y) pixel position on your monitor.

It's this transformation that enables you to take information about an object's position in a 3D environment and figure out exactly where it should be drawn on your screen. 
In practice, this is the core of how an ESP works: without W2S, you can know an enemy's position in the game world, but you wouldn't know where to render the box, snapline, or 
marker on your screen.

### World to Screen Code Explanation:

<div class="cpp-code"><span class="keyword">bool</span> <span class="function">WorldToScreen</span>(
    <span class="keyword">const</span> <span class="type">Vec3</span>& <span class="var">worldPos</span>,
    <span class="type">Vec2</span>& <span class="var">screenPos</span>,
    <span class="keyword">const</span> <span class="type">Matrix4x4</span>& <span class="var">viewProj</span>,
    <span class="type">int</span> <span class="var">screenWidth</span>,
    <span class="type">int</span> <span class="var">screenHeight</span>)
{
    <span class="comment">// Multiply the world position by the view-projection matrix (row-major)</span>
    <span class="type">float</span> <span class="var">x</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">0</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">0</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">0</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">0</span>];
    <span class="type">float</span> <span class="var">y</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">1</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">1</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">1</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">1</span>];
    <span class="type">float</span> <span class="var">z</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">2</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">2</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">2</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">2</span>];
    <span class="type">float</span> <span class="var">w</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">3</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">3</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">3</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">3</span>];

    <span class="comment">// Clip check</span>
    <span class="keyword">if</span> (<span class="var">w</span> &lt; <span class="number">0.0001f</span>)
        <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="comment">// Normalize device coordinates</span>
    <span class="type">float</span> <span class="var">invW</span> = <span class="number">1.0f</span> / <span class="var">w</span>;
    <span class="var">x</span> *= <span class="var">invW</span>;
    <span class="var">y</span> *= <span class="var">invW</span>;

    <span class="comment">// Convert to screen space</span>
    <span class="var">screenPos</span>.<span class="var">x</span> = (<span class="var">x</span> * <span class="number">0.5f</span> + <span class="number">0.5f</span>) * <span class="var">screenWidth</span>;
    <span class="var">screenPos</span>.<span class="var">y</span> = (<span class="number">1.0f</span> - (<span class="var">y</span> * <span class="number">0.5f</span> + <span class="number">0.5f</span>)) * <span class="var">screenHeight</span>; <span class="comment">// Invert Y for top-left origin</span>

    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</div>

We’ll go through the WorldToScreen function line by line to see how a 3D world position gets converted into a 2D screen coordinate.

### World Space → Clip Space

<div class="cpp-code"><span class="type">float</span> <span class="var">x</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">0</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">0</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">0</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">0</span>];
<span class="type">float</span> <span class="var">y</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">1</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">1</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">1</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">1</span>];
<span class="type">float</span> <span class="var">z</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">2</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">2</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">2</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">2</span>];  
<span class="type">float</span> <span class="var">w</span> = <span class="var">worldPos</span>.<span class="var">x</span> * <span class="var">viewProj</span>.m[<span class="number">0</span>][<span class="number">3</span>] + <span class="var">worldPos</span>.<span class="var">y</span> * <span class="var">viewProj</span>.m[<span class="number">1</span>][<span class="number">3</span>] + <span class="var">worldPos</span>.<span class="var">z</span> * <span class="var">viewProj</span>.m[<span class="number">2</span>][<span class="number">3</span>] + <span class="var">viewProj</span>.m[<span class="number">3</span>][<span class="number">3</span>];
</div>

- This is a 4D vector-matrix multiplication. It's transforming the Vec3 worldPos into a 4D (x, y, z, w) coordinate.
- **Why do we do this?:** This single calculation transforms a point from World space to Clip space by simultaneously moving the entire game world so the camera is at the center 
(the View transformation) and applying the perspective squish that makes distant objects appear smaller (the Projection transformation). 
- We assume a 1.0 for the 4th component of the position.

### Clip Check

<div class="cpp-code"><span class="keyword">if</span> (<span class="var">w</span> &lt; <span class="number">0.0001f</span>)
    <span class="keyword">return</span> <span class="keyword">false</span>;
</div>

- This is a safety check to discard any points that are behind the camera.
- The *w* value from the previous step tells us the point's depth relative to the camera.
	- If w>0, the point is in front of the camera.
	- If w<0, the point is behind the camera.
	- If w=0, the point is exactly on the camera's "film," which is an invalid state.
- Returning false ensures we don’t try to draw points that are out of view.

### Clip Space → NDC

<div class="cpp-code"><span class="type">float</span> <span class="var">invW</span> = <span class="number">1.0f</span> / <span class="var">w</span>;
<span class="var">x</span> *= <span class="var">invW</span>;
<span class="var">y</span> *= <span class="var">invW</span>;
</div>

- This is the Perspective Divide, this is what makes distant objects appear smaller. By dividing the x and y coordinates by their w (depth), we "squish" their screen positions.
- A point far away will have a large w, so dividing x by a large number makes the resulting x small. Conversely, a point close to the camera will have a small w, so 
dividing by a small number keeps x large, making it appear to take up more space on the screen. 
- **Why do we Multiply instead of Divide?:** This is an optimization. Division is a "slow" CPU operation. Multiplying is "fast." So instead of doing x / w and y / w (two 
divisions), we do one division to get invW (the inverse of w) and then do two fast multiplications
- The resulting x and y are now in Normalized Device Coordinates (NDC). This is a standardized, abstract space where the screen is a 2D box from -1 to +1.

### NDC → Screen Space

<div class="cpp-code"><span class="var">screenPos</span>.<span class="var">x</span> = (<span class="var">x</span> * <span class="number">0.5f</span> + <span class="number">0.5f</span>) * <span class="var">screenWidth</span>;
<span class="var">screenPos</span>.<span class="var">y</span> = (<span class="number">1.0f</span> - (<span class="var">y</span> * <span class="number">0.5f</span> + <span class="number">0.5f</span>)) * <span class="var">screenHeight</span>; 
</div>

- These lines convert NDC coordinates to actual screen pixels.
- Explanation of x:
	- x * 0.5f + 0.5f maps [-1,1] to [0,1].
	- Multiply by screenWidth to scale to the actual width of your monitor.
- Explanation of y:
	- y * 0.5f + 0.5f also maps [-1,1] → [0,1].
	- 1.0f - (...) inverts the Y-axis because screen coordinates usually have (0,0) at the top-left corner.

<div class="cpp-code"><span class="keyword">return</span> <span class="keyword">true</span>;
</div>

- Finally, if the point passed all checks, the function returns true and screenPos now contains the 2D coordinates where the world point 
should be drawn.

### Summary of the Transformation Pipeline

1. World Space → Clip Space: Multiply by the ViewProjection matrix.
2. Clip Space → NDC: Divide by w (perspective divide).
3. NDC → Screen Space: Scale to your screen’s width and height, flipping Y-axis as needed.

*This step-by-step breakdown shows that World to Screen is really just a series of linear algebra transformations*

#### TL;DR of w2s:

**Take your entity’s position as a Vec4(x, y, z, 1), multiply it by the ViewProjection matrix, perform a clip check to discard points behind the camera, then divide by w to get 
Normalized Device Coordinates (NDC) and finally convert those to screen space. That’s essentially what World-to-Screen (W2S) does.**
