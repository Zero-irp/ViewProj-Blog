---
layout: post
title: "4.3: Completing the View-Projection Matrix"
date: 2025-07-17 00:00:00 +0530
permalink: /part-4.3-completing-view-proj-matrix/
---

<style>
.ida-code{
  background:#1e1e1e;
  color:#dcdcdc;
  padding:12px;
  border-radius:8px;
  font-family: Consolas, "Liberation Mono", Menlo, monospace;
  font-size:14px;
  line-height:1.4;
  overflow-x:auto;
  white-space: pre; /* preserve spaces and linebreaks */
}

/* token classes you can use inside the div */
.ida-code .kw    { color:#569cd6; } /* keywords */
.ida-code .type  { color:#4ec9b0; } /* types */
.ida-code .fn    { color:#dcdcaa; } /* functions / intrinsics */
.ida-code .num   { color:#b5cea8; } /* numbers / hex */
.ida-code .var   { color:#9cdcfe; } /* variables */
.ida-code .const { color:#ce9178; } /* globals / constants */
.ida-code .comment{ color:#6a9955; font-style:italic; }
</style>

In the previous section, we built the View-Projection matrix without translation. now it’s time to dive into the function that actually puts everything together into the full 
View-Projection matrix.

<div class="ida-code"><span class="kw">char</span> <span class="kw">__fastcall</span> <span class="fn">sub_7FBF10</span>(<span class="type">__int64</span> <span class="var">a1</span>, <span class="type">__m128</span> *<span class="var">a2</span>, <span class="type">__m128</span> *<span class="var">a3</span>)
{
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x550</span>) = *<span class="var">a2</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x430</span>) = *<span class="var">a3</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x440</span>) = <span class="var">a3</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x450</span>) = <span class="var">a3</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x460</span>) = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="fn">sub_938210</span>(<span class="var">a3</span>, <span class="var">a1</span> + <span class="num">0x4B0</span>);
  <span class="var">result</span> = <span class="fn">_mm_movemask_ps</span>(<span class="fn">_mm_cmplt_ps</span>(*(<span class="type">__m128</span> *)<span class="fn">sub_7CD6F0</span>(&amp;<span class="var">v21</span>, <span class="var">a1</span> + <span class="num">0x430</span>), (<span class="type">__m128</span>)<span class="num">0LL</span>)) == <span class="num">15</span>;
  *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>) = <span class="var">result</span>;
  <span class="var">v7</span> = <span class="var">a3</span>[<span class="num">1</span>];
  <span class="var">v8</span> = *<span class="var">a3</span>;
  <span class="var">v9</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">a2</span>));
  <span class="var">v10</span> = <span class="var">a3</span>[<span class="num">2</span>];
  <span class="var">v11</span> = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v14</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v9</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v15</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v16</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v14</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v14</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
            <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">170</span>), <span class="var">v10</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">255</span>), <span class="var">v11</span>));
  <span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0</span>), *<span class="var">a3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">85</span>), <span class="var">v7</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">255</span>), <span class="var">v11</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(<span class="var">v18</span>, <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">255</span>), <span class="var">v11</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">85</span>), <span class="var">v7</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">0</span>), <span class="var">v8</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v15</span>, <span class="var">v15</span>, <span class="num">255</span>), <span class="var">v11</span>));
  <span class="var">v19</span> = *(<span class="type">unsigned __int64</span> *)(<span class="var">a1</span> + <span class="num">0x6A4</span>);
  <span class="var">v20</span> = <span class="fn">_mm_movelh_ps</span>((<span class="type">__m128</span>)*(<span class="type">unsigned __int64</span> *)(<span class="var">a1</span> + <span class="num">1708</span>), (<span class="type">__m128</span>)<span class="const">xmmword_10F0E00</span>);
  <span class="var">v21</span> = <span class="var">v19</span>;
  <span class="kw">if</span> ( !<span class="const">byte_34ADB00</span> )
  {
    <span class="fn">sub_7F8F40</span>(<span class="var">a1</span>, (<span class="kw">int</span>)&amp;<span class="var">v21</span>, (<span class="kw">int</span>)&amp;<span class="var">v20</span>, <span class="num">6</span>, <span class="var">a1</span> + <span class="num">1264</span>);
    <span class="var">result</span> = *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>);
    *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x771</span>) = <span class="var">result</span>;
  }
  <span class="kw">return</span> <span class="var">result</span>;
}
</div> 

Remember the final call to sub_7FBF10 in the previous function:  

```cpp
return sub_7FBF10(camStruct, &v15, v16);
```

- So the first Argument a1 is the camStruct
- Second argument a2 is the CameraPostion
- Third argument a3 is the View-Projection Matrix without Translation

Lets rename as such and continue.  

## Matrix Loading into Memory:  


<div class="ida-code">  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x550</span>) = *<span class="var">CamPos</span>;
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x430</span>) = *<span class="var">VP_NoTrans</span>;
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x440</span>) = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x450</span>) = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">CamStruct</span> + <span class="num">0x460</span>) = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
</div>

- Loads Camera Position into CamStruct + 0x550
- Loads VP Matrix (No_translation) into CamStruct + 0x430

**Matrix Inverse**  

<div class="ida-code"><span class="fn">sub_938210</span>(<span class="var">a3</span>, <span class="var">a1</span> + <span class="num">0x4B0</span>);
</div>

We wont dive into this but this basically Makes an inverse Matrix of ViewProj_No_t and saves it to a pointer Camstruct + 0x4B0  

**We will be skipping functions and instructions that dont seem interesting as it is out of scope for this blog**  

## Making sense:  

Let's Try and make sense of this and rename all relevent variables.  

<div class="ida-code">  <span class="var">v7</span> = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  <span class="var">v8</span> = *<span class="var">VP_NoTrans</span>;
  <span class="var">v9</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">a2</span>));
  <span class="var">v10</span> = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  <span class="var">v11</span> = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v14</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v9</span>, <span class="num">0xA0</span>), <span class="num">0x24</span>);
  <span class="var">v15</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v16</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v14</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v14</span>, <span class="num">0xA0</span>), <span class="num">0x24</span>);
</div>

Here is a renamed and cleaned up version.

<div class="ida-code">  <span class="var">VP_NoTrans_Row1</span> = <span class="var">VP_NoTrans</span>[<span class="num">1</span>];
  <span class="var">VP_NoTrans_Row0</span> = *<span class="var">VP_NoTrans</span>;
  <span class="var">CamPos_Negated_w0</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">CamPos</span>));
  <span class="var">VP_NoTrans_Row2</span> = <span class="var">VP_NoTrans</span>[<span class="num">2</span>];
  <span class="var">VP_NoTrans_Row3</span> = <span class="var">VP_NoTrans</span>[<span class="num">3</span>];
  <span class="var">Mask_0010</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">Mask_0100</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">CamPos_Negated_w1</span> = <span class="fn">_mm_shuffle_ps</span>(
		        <span class="var">CamPos_Negated_w0</span>, 
		        <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w0</span>, <span class="num">0xA0</span>), 
	                <span class="num">0x24</span>);
  <span class="var">Mask_1000</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="comment">// -CamPos with w = 1</span>
  <span class="var">CamPos_Negated_w1_dup</span> = <span class="fn">_mm_shuffle_ps</span>(
			    <span class="var">CamPos_Negated_w1</span>, 
			    <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w1</span>, <span class="num">0xA0</span>), 
			    <span class="num">0x24</span>);
</div>

### Another redundant SIMD math function

You might have noticed another redundant SIMD function here. 

<div class="ida-code"><span class="var">CamPos_Negated_w0</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">CamPos</span>));
<span class="var">CamPos_Negated_w1</span> = <span class="fn">_mm_shuffle_ps</span>(
		      <span class="var">CamPos_Negated_w0</span>, 
		      <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w0</span>, <span class="num">0xA0</span>), 
	              <span class="num">0x24</span>);
<span class="var">CamPos_Negated_w1_dup</span> = <span class="fn">_mm_shuffle_ps</span>(
			  <span class="var">CamPos_Negated_w1</span>, 
			  <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">CamPos_Negated_w1</span>, <span class="num">0xA0</span>), 
			  <span class="num">0x24</span>);
</div>


**What does this code do?**

Basically it takes CamPos [x,y,z,w] where w was already '1' and negates it and keeps it '1' at 'w'. 

```cpp
CamPos [x,y,z,1] = [-x,-y,-z,1]
```

There is no reason for such a simple negation to have this many SIMD operations here and are mostly redundant.

### Negated Camera position Multiplication with ViewProjection Matrix

<div class="ida-code"><span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
        <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
        <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>


I’ve already shown how *vec4 × mat4* works in SIMD in my previous post, so I won’t re-explain it here. This is the same thing again.  
it’s just multiplying the negated camera position (with w=1) by the ViewProjection matrix without translation. The result is effectively 
adding the translation into the VP matrix which did not have translation.

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/ida_view_matrix_math.png)

Now lets make sense of the rest of the SIMD matrix math seen here.

### Even More redundant SIMD operations

there are useless vec4 × mat4 littered throughout the function, like here:

<div class="ida-code">*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                            <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xFFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>

you might be surprised but this whole SIMD spaghetti can be reduced to just a single assignment:  

<div class="ida-code">*(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) =  <span class="var">VP_NoTrans_Row2</span>;
</div>

**Why?**

The Mask_0010 vector value is (0, 0, 1, 0).

The code multiplies this mask by each row of the matrix:

- 0 * Row0 = Zero
- 0 * Row1 = Zero
- 1 * Row2 = Row2
- 0 * Row3 = Zero

Adding these together: Zero + Zero + Row2 + Zero = Row2.

This mask makes sure that only the 2nd row gets preserved and the rest get zeroed out.

#### Biggest reduction in SIMD operations:  

**Here is the biggest reduction in SIMD operations**

From:

<div class="ida-code"> <span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(
	 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0010</span>, <span class="var">Mask_0010</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(<span class="var">v18</span>, <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_0100</span>, <span class="var">Mask_0100</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0</span>), <span class="var">VP_NoTrans_Row0</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">Mask_1000</span>, <span class="var">Mask_1000</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));

</div>


To:

<div class="ida-code">  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x240</span>) = <span class="var">VP_NoTrans_Row0</span>
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="var">VP_NoTrans_Row1</span>
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="var">VP_NoTrans_Row2</span>
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>
</div>

- Mask_1000 is (1, 0, 0, 0)
- Mask_0100 is (0, 1, 0, 0)
- Mask_0010 is (0, 0, 1, 0)

Multiplying a unit vector by a matrix simply extracts the corresponding row. The original code was 
laboriously performing this extraction manually for each axis:

- The calculation for 0x240 used Mask_1000 to extract Row0.
- The calculation for 0x250 used Mask_0100 to extract Row1.
- The calculation for 0x260 used Mask_0010 to extract Row2.

*We will Actually manually optimize SIMD assembly instructions to make use of this finding in the next post.*  

### Continuaton of Manual Matrix Reconstruction

The last SIMD math operation we need to do before we get the entire ViewProjection Matrix is:

<div class="ida-code"><span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
        <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0x55</span>), <span class="var">VP_NoTrans_Row1</span>), 
	    <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0</span>), *<span class="var">VP_NoTrans</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xAA</span>), <span class="var">VP_NoTrans_Row2</span>)),
        <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">CamPos_Negated_w1_dup</span>, <span class="var">CamPos_Negated_w1_dup</span>, <span class="num">0xFF</span>), <span class="var">VP_NoTrans_Row3</span>));
</div>

which is basically:

```cpp
CamPos_Negated_w1_dup[Vec4] * VP_NoTrans[Matrix]
```

Let's use our previous snapshot where: 

Camera World Matrix:  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.2/cam-world-matrix.png)

ViewProjection Matrix (Without Translation):  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.2/VP_matrix.png)

- CamPos = [-112913.200, -613576.900, 2234.394, 1.00]
- CamPos_Negated = [112913.200, 613576.900, -2234.394, 1.00]

Now let’s multiply this negated camera position with the ViewProjection Matrix (without translation) to confirm if we get the full 
ViewProjection matrix:  
>Floating-point precision of 13 was used during multiplication to keep results accurate.

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/VP_full_result.png)
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/VP_matrix_full.png)

**Last Row Matches Perfectly**

### The ViewProjection Matrix - Fully Reversed

Let's Recap what we have uncovered by reversing the entire construction of the VP matrix down to its SIMD operations.  

Our initial problem was straightforward:  
Multiplying the View and Projection matrices directly did not produce the correct ViewProjection (VP) matrix used by the engine

After reversing and verifying, down to the SIMD instruction level, we discovered how the game actually constructs its View matrix from the Camera World matrix:

- Row[0] → becomes Column[2]
- Row[1] → becomes –Column[0]
- Row[2] → becomes Column[1]
- Row[3] → becomes (0, 0, 0, 1)

Once this View matrix is built, the engine multiplies it with the Projection matrix to produce an intermediate matrix, essentially the ViewProjection matrix without the 
translation component applied yet.

Finally, the engine takes this intermediate matrix and multiplies it with the negated camera position, producing the final ViewProjection matrix:

- Row[0] → becomes Column[2]
- Row[1] → becomes –Column[0]
- Row[2] → becomes Column[1]
- Row[3] → Computed as -dot(vec, CamPos)

> Note: Multiplying the negated camera position with the ViewProjection matrix (without the translation term) is mathematically equivalent to
–dot(vec, CamPos) as explained in part [4.2: Fast inverse for orthonormal Matrices](../part-4.2-reversing-simd-instrustions/#fast-inverse-for-orthonormal-matrices)

### Final Verification:

Let's take the Camera world Matrix:  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.2/cam-world-matrix.png)

And the Projection Matrix as:  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/projection_matrix.png)

Trying to construct the intermediate Matrix (ViewProjection matrix without the translation) by following:  

- Row[0] → becomes Column[2]
- Row[1] → becomes –Column[0]
- Row[2] → becomes Column[1]
- Row[3] → becomes (0, 0, 0, 1)

We get:  

$$
Intermediate Matrix =
\begin{bmatrix}
-0.906 & -0.072 & 0.416 & 0 \\
-0.423 & 0.154 & -0.893 & 0 \\
0 & 0.985 & 0.170 & 0 \\
0 & 0 & 0 & 1.0
\end{bmatrix}
$$

Multiply it with the projection Matrix:  

$$
\text{IntermediateMatrix} \times \text{ProjectionMatrix} =
\begin{bmatrix}
-0.906 & -0.072 & 0.416 & 0 \\
-0.423 & 0.154 & -0.893 & 0 \\
0 & 0.985 & 0.170 & 0 \\
0 & 0 & 0 & 1.0
\end{bmatrix}
\times
\begin{bmatrix}
1.264 & 0.000 & 0.000 & 0.000 \\
0.000 & 2.247 & 0.000 & 0.000 \\
0.000 & 0.000 & 0.000 & 1.000 \\
0.000 & 0.000 & 10.000 & 0.000
\end{bmatrix}
$$

Result:  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/result_vp_notrans.png)

Comparing aganist in-game memory:  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.2/VP_matrix.png)

Great, It matches.

Next is multiplying the negated camera position with this Matrix:  

$$
\text{negCamPos} \times \text{ProjectionMatrix} =
\begin{bmatrix}
112913.16 & 613576.88 & -2234.39 & 1 
\end{bmatrix}
\times
\begin{bmatrix}
-1.146 & -0.161 & 0.000 & 0.416 \\
-0.534 & 0.346 & 0.000 & -0.893 \\
0.000 & 2.215 & 0.000 & 0.170 \\
0.000 & 0.000 & 10.000 & 0.000
\end{bmatrix}
$$

Result:  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/VP_full_result.png)

Comparing against in-game memory:

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/VP_matrix_full.png)

Doing this in one Matrix Multiply we get a View Matrix that is built something like this:  

$$
\text{ViewMatrix} \times \text{ProjectionMatrix} =
\begin{bmatrix}
-u_x & f_x & r_x & 0 \\
-u_y & f_y & r_y & 0 \\
-u_z & f_z & r_z & 0 \\
dot(u, p) & -dot(f, p) & -dot(r, p) & 1.0
\end{bmatrix}
\times
\begin{bmatrix}
1.264 & 0.000 & 0.000 & 0.000 \\
0.000 & 2.247 & 0.000 & 0.000 \\
0.000 & 0.000 & 0.000 & 1.000 \\
0.000 & 0.000 & 10.000 & 0.000
\end{bmatrix}
$$

Thus confriming that:  

$$
\text{ViewMatrix} \times \text{ProjectionMatrix} =
\begin{bmatrix}
-0.906 & -0.072 & 0.416 & 0 \\
-0.423 & 0.154 & -0.893 & 0 \\
0 & 0.985 & 0.170 & 0 \\
-361842.34 & 84160.3 & -501332.11 & 1.0
\end{bmatrix}
\times
\begin{bmatrix}
1.264 & 0.000 & 0.000 & 0.000 \\
0.000 & 2.247 & 0.000 & 0.000 \\
0.000 & 0.000 & 0.000 & 1.000 \\
0.000 & 0.000 & 10.000 & 0.000
\end{bmatrix}
$$

Gives us the Full View Projection Matrix:  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.3/vp_result_4x4.png)

### Camera World Matrix Does Not Match?

The camera world matrix we found was:  

$$
C_{world} =
\begin{bmatrix}
r_x & r_y & r_z & 0 \\
u_x & u_y & u_z & 0 \\
f_x & f_y & f_z & 0 \\
p_x & p_y & p_z & 1.0
\end{bmatrix}
$$

but it's inverse is supposed to be:  

$$
C_{world}^{-1} =
\begin{bmatrix}
r_x & u_x & f_x & 0 \\
r_y & u_y & f_y & 0 \\
r_z & u_z & f_z & 0 \\
-dot(r, P) & -dot(u, P) & -dot(f, P) & 1.0
\end{bmatrix}
$$

However, the actual view matrix we recovered from the game looks very different: 

$$
\text{ViewMatrix} =
\begin{bmatrix}
-u_x & f_x & r_x & 0 \\
-u_y & f_y & r_y & 0 \\
-u_z & f_z & r_z & 0 \\
dot(u, p) & -dot(f, p) & -dot(r, p) & 1.0
\end{bmatrix}
$$

Whatever matrix the engine uses to position the camera in world space (the camera’s world matrix), its inverse must be the view matrix.
That’s absolute. So i'm sure the camera world matrix we found in memory was not infact the actual matrix used by the engine for it's internal camera transform.  
Instead, the engine likely uses this layout:

$$
C_{world} =
\begin{bmatrix}
-u_x & -u_y & -u_z & 0 \\
f_x & f_y & f_z & 0 \\
r_x & r_y & r_z & 0 \\
p_x & p_y & p_z & 1.0
\end{bmatrix}
$$

Applying the fast inverse formula: 

$$
C_{world}^{-1} =
\begin{bmatrix}
R^T & 0 \\
-TR^T & 1
\end{bmatrix}
$$

produces the exact view matrix used by the engine. 
  
Thus pretty much confirming the Camera's world matrix we found in memory is in a textbook layout and not the actual layout used for the 
camera transform.  

In short, the camera world matrix doesn’t have to follow the textbook layout.
As long as the engine is consistent in how it expects and inverts it, the result will always be valid.

### Completion of VP matrix construction from SIMD operations


Thus completes the reconstruction of the ViewProjection matrix, starting from theoretical concepts, all the way to manual SIMD-level verification. 
Not only does this resolve the original discrepancy, but it also provides a concrete bridge between mathematical theory, graphics pipelines, and 
reverse engineering practice.

*Next up: Trimming down redundant SIMD instructions using assembly patching and trampoline hooking. Don’t expect a real performance gain here, 
it’s more about recognizing wasted ops and experimenting with how far we can push the pipeline by hand.*






















