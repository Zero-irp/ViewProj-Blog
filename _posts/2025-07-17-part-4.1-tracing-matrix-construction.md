---
layout: post
title: "Part 4.1: Tracing the Matrix Construction Path"
date: 2025-07-17 00:00:00 +0530
permalink: /part-4.1-tracing-matrix-construction/
---

### Tracing Functions Writing to The View-Projection Matrix

Lets start by observing which function writes to the View-Projection Matrix by clicking on the "Find out what writes this address" on the first element
of the View-Projection Matrix.  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/find-what-writes-vpmatrix.png)

We have found 2 different functions that seem to write to this address.
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/found-what-writes-vpmatrix.png)

The first instruction seems to reference an address "VCRUNTIME140.memset+134:" and the second one reference's "GhostOfTsushima.exe+9AA0AF:".  
The second instruction intregiues me more so lets look at that one.  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/9aa082-ins-asm-ce.png) 

Here [rdi+0x5C0] is our static memory address of the view projection matrix and is getting written into by "xmm0".

>In x64 systems, xmm registers are part of the SSE (Streaming SIMD Extensions) register set. Each xmm register is 
128 bits wide, which makes them ideal for handling vectors, matrices, and other packed floating-point operations. Modern Games use 
SIMD ("Single instruction Multiple Data") instructions using these registers to optimize performance when doing things like 
matrix math and transformations.

Lets now see where "xmm0" gets its 4, 32bit float values from. In the instruction just above we see "xmm0" gets its value from  
"movups xmm0,[rax+00000240]" which means [rax+00000240] would be where it seems to copy the values from.

**lets see this entire function in ida before moving further**  

lets "select current function" in cheat engine to get the function start address which is "GhostOfTsushima.exe+9AA040".  
Lets put this in ida and see its pseudo-code.
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/ida-view-9aa082.png)

>Don’t forget to rebase IDA to "0" before searching for the address in the function subview!  
Alternatively, you can calculate the offset between the Cheat Engine base and the IDA base manually using a calculator.

While stepping through the function, I didn’t encounter many SIMD instructions like "mm_mul", "mm_add_ps", or "mm_shuffle_ps".
Instead, it appears that the function is primarily copying matrices from dynamic memory into this static location,  possibly from a 
camera struct or a similar source.

