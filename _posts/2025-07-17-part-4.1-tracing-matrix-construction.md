---
layout: post
title: "Part 4.1: Tracing the Matrix Construction Path"
date: 2025-07-17 00:00:00 +0530
permalink: /part-4.1-tracing-matrix-construction/
---

<style>
.ida-code{
  background:#1e1e1e;
  color:#dcdcdc;
  padding:12px;
  border-radius:8px;
  font-family: Consolas, "Liberation Mono", Menlo, monospace;
  font-size:14px;
  line-height:1.4;
  overflow-x:auto;
  white-space: pre; /* preserve spaces and linebreaks */
}

/* token classes you can use inside the div */
.ida-code .kw    { color:#569cd6; } /* keywords */
.ida-code .type  { color:#4ec9b0; } /* types */
.ida-code .fn    { color:#dcdcaa; } /* functions / intrinsics */
.ida-code .num   { color:#b5cea8; } /* numbers / hex */
.ida-code .var   { color:#9cdcfe; } /* variables */
.ida-code .const { color:#ce9178; } /* globals / constants */
.ida-code .comment{ color:#6a9955; font-style:italic; }
</style>

### Tracing Functions Writing to The View-Projection Matrix

Lets start by observing which function writes to the View-Projection Matrix by clicking on the "Find out what writes this address" on the first element
of the View-Projection Matrix.  

![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/find-what-writes-vpmatrix.png)

We have found 2 different functions that seem to write to this address.
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/found-what-writes-vpmatrix.png)

The first instruction seems to reference an address "VCRUNTIME140.memset+134:" and the second one references "GhostOfTsushima.exe+9AA0AF:".  
The second instruction intrigues me more so lets look at that one.  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/9aa082-ins-asm-ce.png) 

Here [rdi+0x5C0] is our static memory address of the view projection matrix and is getting written into by "xmm0".

>On x64, you’ll often see xmm0–xmm15 in the disassembly. These are 128-bit registers the CPU uses for SIMD (“Single Instruction, Multiple Data”) work, 
basically crunching multiple floats at once (4-32bit floats). Games use these for stuff like matrix math, vector transforms, and physics, 
because it’s faster than doing one number at a time.

Lets now see where "xmm0" gets its 4, 32bit float values from. In the instruction just above we see "xmm0" gets its value from  
"movups xmm0,[rax+00000240]" which means [rax+00000240] would be where it seems to copy the values from.

**lets see this entire function in IDA before moving further**  

lets "select current function" in cheat engine to get the function start address which is "GhostOfTsushima.exe+9AA040".  
Lets put this in IDA and see its pseudo-code.
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/ida-view-9aa082.png)

>Don’t forget to rebase IDA to "0" before searching for the address in the function sub-view!  
Alternatively, you can calculate the offset between the Cheat Engine base and the IDA base manually using a calculator.

While stepping through the function, I didn’t encounter many SIMD instructions like "mm_mul", "mm_add_ps", or "mm_shuffle_ps" (only a few).
Instead, it appears that the function is primarily copying matrices from dynamic memory into this static location,  possibly from a 
camera struct or a similar source.  

Let's now see what function writes to the dynamic address that its copying from - ([rax+0x240]):
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/matrix-copy-ins-write.png)

We can see one instruction reference "GhostOfTsushima.exe+7FC11B:". Let's select the current function and plug it into ida to see its pseudo code.  

<div class="ida-code"><span class="kw">char</span> <span class="kw">__fastcall</span> <span class="fn">sub_7FBF10</span>(<span class="type">__int64</span> <span class="var">a1</span>, <span class="type">__m128</span> *<span class="var">a2</span>, <span class="type">__m128</span> *<span class="var">a3</span>)
{
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x550</span>) = *<span class="var">a2</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x430</span>) = *<span class="var">a3</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x440</span>) = <span class="var">a3</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x450</span>) = <span class="var">a3</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x460</span>) = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="fn">sub_938210</span>(<span class="var">a3</span>, <span class="var">a1</span> + <span class="num">0x4B0</span>);
  <span class="var">result</span> = <span class="fn">_mm_movemask_ps</span>(<span class="fn">_mm_cmplt_ps</span>(*(<span class="type">__m128</span> *)<span class="fn">sub_7CD6F0</span>(&amp;<span class="var">v21</span>, <span class="var">a1</span> + <span class="num">0x430</span>), (<span class="type">__m128</span>)<span class="num">0LL</span>)) == <span class="num">15</span>;
  *(_BYTE *)(<span class="var">a1</span> + <span class="num">0x770</span>) = <span class="var">result</span>;
  <span class="var">v7</span> = <span class="var">a3</span>[<span class="num">1</span>];
  <span class="var">v8</span> = *<span class="var">a3</span>;
  <span class="var">v9</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>, *<span class="var">a2</span>));
  <span class="var">v10</span> = <span class="var">a3</span>[<span class="num">2</span>];
  <span class="var">v11</span> = <span class="var">a3</span>[<span class="num">3</span>];
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D00</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CF0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v14</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v9</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v15</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138CE0</span>, (<span class="type">__m128</span>)<span class="const">NaNNaNNaN0f_Mask</span>);
  <span class="var">v16</span> = <span class="fn">_mm_shuffle_ps</span>(<span class="var">v14</span>, <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">Mask_1111f</span>, <span class="var">v14</span>, <span class="num">160</span>), <span class="num">36</span>);
  <span class="var">v17</span> = <span class="fn">_mm_add_ps</span>(
          <span class="fn">_mm_add_ps</span>(
            <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
            <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">170</span>), <span class="var">v10</span>)),
          <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v16</span>, <span class="var">v16</span>, <span class="num">255</span>), <span class="var">v11</span>));
  <span class="var">v18</span> = <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">85</span>), <span class="var">v7</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0</span>), *<span class="var">a3</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x260</span>) = <span class="fn">_mm_add_ps</span>(
                              <span class="fn">_mm_add_ps</span>(
                                <span class="fn">_mm_add_ps</span>(
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">85</span>), <span class="var">v7</span>),
                                  <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0</span>), *<span class="var">a3</span>)),
                                <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">170</span>), <span class="var">v10</span>)),
                              <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">255</span>), <span class="var">v11</span>));
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x270</span>) = <span class="var">v17</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x250</span>) = <span class="fn">_mm_add_ps</span>(..............
</div> 

> This is just a snippet of the start of the function.

### Windows Calling Conventions (ABI)

On Windows x64, functions follow the Microsoft x64 calling convention. That means the first four parameters are passed in registers:

- RCX → first argument (a1)
- RDX → second argument (a2)
- R8 → third argument (a3)
- R9 → fourth argument (a4)

If there are more than four, the extras get pushed onto the stack. The return value usually ends up in RAX.

So if we see a function labeled with a1, a2, a3, those are just the values RCX, RDX, and R8 were holding when the function was called.

### Breakpoint & Stacktrace

To figure out exactly what’s being passed in, we can set a breakpoint right at the start of the function in Cheat Engine, then check those registers. 
That’ll give us a live snapshot of the arguments 
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/ce-7fbf10-breakpoint.png)

For now, the only argument of interest is a1, which corresponds to RCX. In this particular call, RCX = 0x2D72494D200.  
I consider it “interesting” because of the following code snippet inside sub_7FBF10:  

<div class="ida-code">  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x550</span>) = *<span class="var">a2</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x430</span>) = *<span class="var">a3</span>;
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x440</span>) = <span class="var">a3</span>[<span class="num">1</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x450</span>) = <span class="var">a3</span>[<span class="num">2</span>];
  *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x460</span>) = <span class="var">a3</span>[<span class="num">3</span>];
</div>
looking through the function we notice that it loads a single 4x4 matrix and a Vector4 near the start.  
Let’s inspect the values at those offsets in memory.  
At [a1 + 0x430], we find what appears to be a ViewProjection matrix without the translation component:  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/reclass-view-proj-no-trans.png)  

And at [a1 + 0x550], we find a Vector4 that corresponds to the camera position:   
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/reclass-cam-pos.png)

Since this function receives the view-projection matrix (without translation) as input, we can reasonably guess that the actual 
multiplication of the View and Projection matrices happens somewhere earlier in the call stack. this function isn’t building the full VP 
matrix from scratch, it’s taking an intermediate version and adding the translation part to make the final matrix the renderer uses. 

>We’ll break down this function in detail later, but for now, our goal is to trace the data flow further upstream to locate where 
this matrix begins its construction.

Let's breakpoint at the start of the function and use the "stack trace" feature in cheat engine.  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/ce-stack-trace-realfunc.png)  

The first function is the function we are inside of.  
The instruction at GhostOfTsushima.exe+7FD233 belongs to the function that called our current function (0x7FBF10).

We'll grab the start address of the caller and plug it inside of IDA for further analysis.  

### IDA Code:  

<div class="ida-code"><span class="kw">char</span> <span class="kw">__fastcall</span> <span class="fn">sub_7FD060</span>(<span class="type">__int64</span> <span class="var">a1</span>)
{
  <span class="type">__m128</span> <span class="var">v1</span>; <span class="comment">// xmm7</span>
  <span class="type">__m128</span> <span class="var">v2</span>; <span class="comment">// xmm1</span>
  <span class="type">__m128</span> <span class="var">v3</span>; <span class="comment">// xmm6</span>
  <span class="type">__m128</span> <span class="var">v4</span>; <span class="comment">// xmm2</span>
  <span class="type">__m128</span> <span class="var">v5</span>; <span class="comment">// xmm9</span>
  <span class="type">__m128</span> <span class="var">v6</span>; <span class="comment">// xmm10</span>
  <span class="type">__m128</span> <span class="var">v7</span>; <span class="comment">// xmm13</span>
  <span class="type">__m128</span> <span class="var">v8</span>; <span class="comment">// xmm12</span>
  <span class="type">__m128</span> <span class="var">v9</span>; <span class="comment">// xmm5</span>
  <span class="type">__m128</span> <span class="var">v10</span>; <span class="comment">// xmm12</span>
  <span class="type">__m128</span> <span class="var">v11</span>; <span class="comment">// xmm5</span>
  <span class="type">__m128</span> <span class="var">v12</span>; <span class="comment">// xmm8</span>
  <span class="type">__m128</span> <span class="var">v13</span>; <span class="comment">// xmm12</span>
  <span class="type">__m128</span> <span class="var">v15</span>; <span class="comment">// [rsp+20h] [rbp-E8h] BYREF</span>
  <span class="type">__m128</span> <span class="var">v16</span>[<span class="num">4</span>]; <span class="comment">// [rsp+30h] [rbp-D8h] BYREF</span>

  <span class="var">v1</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x210</span>);
  <span class="var">v2</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x160</span>));
  <span class="var">v3</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x200</span>);
  <span class="var">v4</span> = <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x140</span>));
  <span class="var">v5</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x220</span>);
  <span class="var">v6</span> = *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x230</span>);
  <span class="var">v7</span> = <span class="fn">_mm_shuffle_ps</span>(
         *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x170</span>),
         <span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_10F0E70</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x170</span>), <span class="num">160</span>),
         <span class="num">36</span>);
  <span class="var">v8</span> = <span class="fn">_mm_sub_ps</span>((<span class="type">__m128</span>)<span class="num">0LL</span>, <span class="fn">_mm_and_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>, *(<span class="type">__m128</span> *)(<span class="var">a1</span> + <span class="num">0x150</span>)));
  <span class="var">v9</span> = <span class="fn">_mm_unpackhi_ps</span>(<span class="var">v8</span>, <span class="var">v2</span>);
  <span class="var">v10</span> = <span class="fn">_mm_unpacklo_ps</span>(<span class="var">v8</span>, <span class="var">v2</span>);
  <span class="var">v11</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v9</span>, <span class="var">v4</span>, <span class="num">0x24</span>), (<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>);
  <span class="var">v12</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v10</span>, <span class="var">v4</span>, <span class="num">0x1E</span>), (<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>);
  <span class="var">v13</span> = <span class="fn">_mm_and_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v10</span>, <span class="var">v4</span>, <span class="num">4</span>), (<span class="type">__m128</span>)<span class="const">xmmword_1138D50</span>);
  <span class="var">v16</span>[<span class="num">1</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0</span>), <span class="var">v3</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v12</span>, <span class="var">v12</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="var">v16</span>[<span class="num">2</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0</span>), <span class="var">v3</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v11</span>, <span class="var">v11</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="var">v16</span>[<span class="num">3</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(
                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0</span>), <span class="var">v3</span>),
                 <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>((<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, (<span class="type">__m128</span>)<span class="const">xmmword_1138D10</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="var">v15</span> = <span class="var">v7</span>;
  <span class="var">v16</span>[<span class="num">0</span>] = <span class="fn">_mm_add_ps</span>(
             <span class="fn">_mm_add_ps</span>(
               <span class="fn">_mm_add_ps</span>(<span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0</span>), <span class="var">v3</span>), <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0x55</span>), <span class="var">v1</span>)),
               <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0xAA</span>), <span class="var">v5</span>)),
             <span class="fn">_mm_mul_ps</span>(<span class="fn">_mm_shuffle_ps</span>(<span class="var">v13</span>, <span class="var">v13</span>, <span class="num">0xFF</span>), <span class="var">v6</span>));
  <span class="kw">return</span> <span class="fn">sub_7FBF10</span>(<span class="var">a1</span>, &amp;<span class="var">v15</span>, <span class="var">v16</span>);
}
</div>

This function takes a single argument, probably a pointer to the camera structure.  
Notably, it accesses two 4x4 matrices  

[a1+0x200]:  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/a1+200-matrix.png)  
This is just the Projection Matrix.

[a1+0x140]:  
![ESP-Image1](/ViewProj-Blog/assets/images/part-4.1/a1+140-matrix.png)  
This is just the Camera World Matrix.  

Throughout the function, we see use _mm_mul_ps, _mm_add_ps, and _mm_shuffle_ps popping up which is a indicator for SIMD matrix multiplication. 
The v16 array, which is made up of __m128 values, is gradually filled with the result of these operations, effectively forming a 4x4 matrix.  

> ### Why Not Just Invert It?
If you already have both the Projection (P) and the View-Projection (VP) matrices, you can simply compute the View-matrix (V) using *Matrix algebra*.  
If the game uses the row-vector convention (common in DirectX), where the order is:  
$$\begin{align}VP = V \times P\end{align}$$   
Therefore, you can solve for V:  
$$\begin{align} V = VP \times P^{-1}\end{align}$$  
If the game uses the column-vector convention (common in OpenGL), where the order is:  
$$\begin{align}VP = P \times V\end{align}$$   
Then, you can solve for V:  
$$\begin{align}V = P^{-1} \times VP\end{align}$$    
But this lacks the insight into how the engine computes it internally, So we are going to do it the Hard Way.

*Now that we have confirmed that this is probably the matrix construction function of the View-Projection matrix we can now start reversing 
its many SIMD instructions to see what exactly it does with the camera world matrix and projection matrix.*



















